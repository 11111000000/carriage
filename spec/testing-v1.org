#+title: Testing v1 — План тестирования
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t

* Цели
- Гарантировать корректность парсеров, dry-run и применения.
- Покрыть позитивные и негативные сценарии, краевые случаи.

* Наборы тестов
** Юнит-тесты (ERT)
- Парсеры:
  - SRE: корректные/некорректные begin_from/begin_to и директивы #+pair; from→to строго попарно.
  - SRE: превышение лимита пар → SRE_E_LIMITS; отсутствие пар → SRE_E_SEGMENTS_COUNT; from без to → SRE_E_UNPAIRED.
  - SRE: экранирование строк «#+end_from»/«#+end_to» (с одним ведущим пробелом).
  - SRE: :range вне границ → clamp и предупреждение SRE_W_RANGE_CLAMP; одинаковое поведение dry-run/apply.
  - SRE: валидация :occur — только 'first|'all; любые иные значения → SRE_E_OCCUR_VALUE; пустые FROM/TO → SRE_E_EMPTY_SEGMENT.
  - AIBO: literal-only; ключ :match запрещён; :occur 'first|'all (при all обязателен :expect); пустые FROM/TO → SRE_E_EMPTY_SEGMENT.
  - PATCH: многофайловый diff → отказ, /dev/null create/delete.
  - PATCH: :strip логика — по умолчанию 1; если :strip задан и не (целое ≥ 0) → PATCH_E_STRIP.
  - PATCH: отсутствуют заголовки ---/+++ → PATCH_E_DIFF_SYNTAX.
  - PATCH: rename/copy прелюдии → PATCH_E_RENAME_COPY; бинарные секции → PATCH_E_BINARY.
  - PATCH: превышение размера тела (> 4 MiB) → PATCH_E_LIMITS.
  - MODE: алиасы :op запрещены; любые алиасы → MODE_E_DISPATCH.
  - MODE: sanitizer — SRE-блоки не переписываются; для create обязателен и нормализуется :delim (6 lower hex).

  - File Ops: create/replace/delete/rename — предусловия, :mkdir, :ensure-final-newline, конфликты путей и существование/отсутствие файлов; create: валидация :delim (=6 hex, Emacs regexp \\`[0-9a-f]\\{6\\}\\'), негативный кейс при неверном токене.
- Валидаторы regexp (Emacs flavor): неподдерживаемые конструкции → ошибка.
- Нормализация путей: см. ./security-v1.org.
- TRAMP/remote: см. ./security-v1.org (отказ при (file-remote-p) t).
- NOOP-политика: при carriage-mode-sre-noop-on-zero-matches=t и :occur first с 0 совпадений → статус 'skip и предупреждение.
- Begin-iteration: команды отправки (send-buffer/send-subtree) не вызывают carriage-begin-iteration; идентификатор создаётся РОВНО один раз в carriage-transport-begin. Тест через advice/счётчик вызовов.
- Collector fallback: при отсутствии текстовых свойств на #+begin_patch, но при наличии inline-маркера "#+CARRIAGE_ITERATION_ID: <id>", строгий сборщик выбирает все блоки после ПОСЛЕДНЕГО такого маркера до следующего ниже (или конца буфера).
- Load-path init: carriage.el добавляет каталоги lisp/ops, lisp/transports и lisp/engines в load-path с корректными guards (transports-dir проверяется по переменной transports-dir, а не ops-dir).

** Интеграционные
- Тестовый git-репозиторий (временный каталог).
- Apply pipeline:
  - delete → rename → create → patch → sre порядок.
  - Сбой в середине группы → остановка без автоматического отката.
  - Dry-run отчёты и подтверждение.
  - Apply-All strict: при отсутствии метки последней итерации команда отказывается; фоллбэка на «все блоки» нет.
  - Асинхронность: запуск carriage-apply-plan-async возвращает управление немедленно; завершение приходит через колбэк; UI/буфер не блокируется (эмуляция таймера).
  - Abort: при отмене активного шага пайплайн завершается корректно; отчёт помечает aborted.
  - Sync-wrapper (single block): синхронное применение patch использует движок (git), отчёт содержит :pid и :elapsed-ms; поведение совпадает с async по статусам.
  - По умолчанию коммита после apply нет; проверить, что история git не меняется без явной commit-команды.
  - При stage-policy='index изменения оказываются в индексе (git diff --cached не пуст).
  - Команды carriage-commit-changes и carriage-commit-last-iteration создают один коммит; проверить набор файлов и шаблон сообщения.
- Движки:
  - Выбор движка (carriage-select-apply-engine) меняет реализацию шагов; заголовочный :apply игнорируется.
  - Для движка 'git: dry-run вызывает git apply --check; apply — git apply [--index]; ветки по policy ('in-place|'wip|'ephemeral); dry-run не создаёт/не переключает ветки; switch-back и auto-delete пустых ephemeral.
  - Для движка 'emacs: :op 'patch отклоняется (MODE_E_DISPATCH); sre/aibo/create/delete/rename работают без индексации; отказ при несохранённых буферах (policy=t); запись атомарна; порционная обработка для больших файлов.
  - При Suite↔Engine несовместимости: отказ (MODE_E_DISPATCH) и отображение предупреждения в UI (мокаем сообщение).
- gptel-mock: имитация ответа LLM с блоками:
  - Стрим: несколько чанков STRING → t; проверка:
    - UI переходит sending→streaming→idle; спиннер останавливается.
    - В исходном буфере создан «регион ответа» и текст чанков напечатан по мере поступления (сохранение порядка).
    - При (reasoning . TEXT|t) создан и корректно закрыт блок #+begin_reasoning/#+end_reasoning.
  - Ошибка: nil → состояние error, лог и завершение (carriage-transport-complete t); reasoning-блок закрыт.
  - Abort: 'abort → обработчик отмены вызывает gptel-abort; состояние error; reasoning-блок закрыт, регион ответа сброшен.
  - Intent=Code: текст вне блоков =patch= игнорируется на этапе парсинга/применения; «последняя итерация» включает только блоки.
  - Intent=Hybrid: допускается текст вне блоков; парсер извлекает и применяет только блоки.
- echo (dev): без gptel — backend='echo' стримит тестовые чанки, проверяем видимость в *carriage-traffic*, переходы состояний и корректную отмену (abort).

** Золотые документы (golden files)
- Набор org-файлов с известными блоками и ожидаемыми результатами.
- Тесты «без изменений» (идемпотентность).

* Как запускать
- emacs -Q -batch -l ert -l test/run.el -f ert-run-tests-batch-and-exit

* Метрики качества
- Покрытие веток в парсерах и апплаерах.
- Время на dry-run и применение больших файлов (пороговые значения).

* Keyspec/which-key/Menu v1.1 — Доп. тесты
- Биндинги: нормативные команды доступны под C-c e (см. test/carriage-keyspec-bindings-test.el).
- Меню:
  - C-c e открывает transient (если установлен) либо fallback completing-read; пункт :menu не включается.
  - Много-колоночная раскладка transient: группы по секциям (:navigate, :act, :session, :tools, :logs) с заголовками (i18n).
  - Для многоклавишных последовательностей используется последний токен ("t c" → "c"); при коллизиях — стратегия base → UPPER(base) → первая буква :id → цифры "1"…"9".
  - Fallback: метки с префиксами секций в формате "[Section] Label" (Section — i18n).
- which-key: подсказки для "C-c e" (Carriage Menu) и "C-c e t" (Carriage Toggles) регистрируются через i18n.
- I18N:
  - Переключение локали меняет заголовки групп в transient и which-key подписи.
  - При отсутствии перевода — fallback на en, затем на имя ключа.

* UI/Model/Context v1.1 — Доп. тесты
- Mode-line / Model:
  - В модлайне отображается только basename модели (последний сегмент после «:»), без backend/provider.
  - Tooltip при наведении на [MODEL] показывает полный id backend[:provider]:model.
  - Клик по [MODEL] открывает выбор модели; поле ввода предзаполнено текущим полным id.
  - См. тест: test/carriage-ui-modeline-segments-test.el.
- Контекст (тумблеры):
  - [Ctx] — переключает включение gptel-context (по умолчанию on).
  - [Files] — переключает включение файлов из #+begin_context (по умолчанию on).
  - Проверка: наличие обоих тумблеров в модлайне; смена состояния меняет текст подсказки и/или выделение.
- Инъекция контекста:
  - Проверка инъекции в system и user ветки согласно carriage-mode-context-injection.
  - Лимиты: ≤ 100 файлов, ≤ 1024 KiB суммарно; при превышении включаются только пути + summary; предупреждения присутствуют.
  - TRAMP/вне корня — отказ; бинарные файлы — только путь/метаданные.
- Keyspec/which-key/Menu v1.1
  - Биндинги: C-c e … назначены через keyspec; коллизий нет (carriage-keys-lint-collisions).
  - Меню: C-c e открывает transient (если установлен) либо fallback completing-read; :menu исключён из списка пунктов.
  - Уникализация: для многоклавишных последовательностей используется последний токен (например, "t c" → "c"); при коллизиях — стратегия base → upper-case(base) → первая буква :id → цифры "1"…"9".
  - which-key: подсказки для "C-c e" и "C-c e t" регистрируются.

* Примитивные фикстуры (elisp-скелеты)
#+begin_src emacs-lisp
(require 'ert)

;; SRE
(ert-deftest carriage-sre-parse-basic ()
  (should (fboundp 'carriage-parse-sre)))

(ert-deftest carriage-aibo-parse-basic ()
  (should (fboundp 'carriage-parse-aibo)))

(ert-deftest carriage-sre-occur-all-expect-required ()
  (let ((plan '((:version "1" :op 'sre :file "x"
                  :pairs ((:from "a" :to "b" :opts (:occur all)))))))
    ;; skeleton: expect error on dry-run without :expect
    (should t)))

;; Unified diff
(ert-deftest carriage-diff-parse-one-file ()
  (should (fboundp 'carriage-parse-diff)))

(ert-deftest carriage-diff-git-check-fails ()
  ;; skeleton: simulate git apply --check failure
  (should t))

;; File ops
(ert-deftest carriage-create-validate-and-apply ()
  (should (fboundp 'carriage-parse-create)))

(ert-deftest carriage-delete-validate-and-apply ()
  (should (fboundp 'carriage-parse-delete)))

(ert-deftest carriage-rename-validate-and-apply ()
  (should (fboundp 'carriage-parse-rename)))

(ert-deftest carriage-replace-validate-and-apply ()
  (should (fboundp 'carriage-parse-replace)))

;; create no longer uses :delim in v1.1; body is taken as-is between begin/end.
(ert-deftest carriage-create-no-delim-body-as-is ()
  (let ((hdr '(:version "1" :op "create" :file "x")))
    (should (ignore-errors
              (carriage-parse-create hdr "ok\n" default-directory)))))

;; Security and env
(ert-deftest carriage-path-normalization ()
  (should t))

(ert-deftest carriage-tramp-detected-and-refused ()
  (should t))

;; UI/report: таблица должна быть валидной org-table и выравниваться
(ert-deftest carriage-report-renders-org-table ()
  (let ((buf (get-buffer-create "*carriage-report*")))
    (with-current-buffer buf
      (org-mode)
      (erase-buffer)
      (insert "| # | op | path | status | matches | details | preview | actions |\n")
      (insert "|---+----+------+--------+---------+---------+---------+---------|\n")
      (insert "| 1 | create | script.js | fail | 0 | Already exists |  | [Ediff] [Apply] |\n")
      (goto-char (point-min))
      (should (org-at-table-p))
      (org-table-align)
      (should (org-at-table-p)))))

;; UI/source buffer: carriage-mode не выключается и буфер остаётся writable
(ert-deftest carriage-mode-persists-and-writable-after-apply ()
  (with-temp-buffer
    (org-mode)
    (carriage-mode 1)
    (let ((before-ro buffer-read-only))
      ;; эмуляция цикла без изменения исходного буфера
      (run-hooks 'post-command-hook)
      (should (bound-and-true-p carriage-mode))
      (should (eq buffer-read-only before-ro)))))

;; Промпт-билдер (минимальные скелеты)
(ert-deftest carriage-prompt-builder-suite-sre-excludes-udiff ()
  "Suite=sre: system не должен содержать маркеров unified diff."
  (let* ((intent 'Code)
         (suite 'sre)
         (ctx '(:payload "Do X" :files nil))
         ;; Моки registry/overrides по умолчанию должны быть настроены в тестовой среде
         (sys (alist-get :system (carriage--build-prompt intent suite ctx))))
    (should (string-match-p (rx (not (or bol "--- " "+++ " "diff --git"))) sys))
    (should-not (string-match-p (rx bol ("--- " | "+++ " | "diff --git")) sys))
    (should-not (string-match-p (rx "unified diff") sys))))

(ert-deftest carriage-prompt-builder-suite-udiff-excludes-sre ()
  "Suite=udiff: system не должен содержать маркеров SRE begin_from/begin_to."
  (let* ((intent 'Code)
         (suite 'udiff)
         (ctx '(:payload "Do Y"))
         (sys (alist-get :system (carriage--build-prompt intent suite ctx))))
    (should-not (string-match-p (rx "#+begin_from") sys))
    (should-not (string-match-p (rx "#+begin_to") sys))))

(ert-deftest carriage-prompt-builder-intent-overrides-win ()
  "intent override заменяет фрагмент реестра."
  (let* ((intent 'Hybrid)
         (suite 'sre)
         (carriage-intent-fragment-overrides `((,intent . "OVERRIDE HYBRID")))
         (ctx '(:payload "Z")))
    (should (string-match-p "OVERRIDE HYBRID"
                            (alist-get :system (carriage--build-prompt intent suite ctx))))))

(ert-deftest carriage-prompt-builder-op-overrides-win ()
  "op override заменяет фрагмент op-модуля."
  (let* ((intent 'Code)
         (suite 'udiff)
         (carriage-op-fragment-overrides '((patch . "OVERRIDE PATCH FRAGMENT")))
         (sys (alist-get :system (carriage--build-prompt intent suite '(:payload "P")))))
    (should (string-match-p "OVERRIDE PATCH FRAGMENT" sys))))

* Keyspec/UI v1.2 — Глобальный префикс, контексты и open-buffer
- Префикс/Transient:
  - В carriage-mode и carriage-mode-use-transient=t на "C-c e" открывается меню (transient|fallback).
  - При carriage-mode-use-transient=nil "C-c e" — префикс; последовательности "C-c e t c" работают.
  - Вне carriage-mode "C-c e" не занят, кроме включённого carriage-global-mode.
- Глобальный режим:
  - При включённом carriage-global-mode "C-c e" доступен глобально; меню/префикс строятся только из :contexts (global).
  - В буфере carriage-mode глобальные клавиши доступны и могут перекрываться локальными; локальные имеют приоритет.
  - Примечание о «перехвате последовательности»: когда "C-c e" привязан к команде (transient=t), Emacs перехватывает последовательность целиком и глобальный суффикс "e" не сработает; это ожидаемо.
- Контексты дочерних режимов:
  - report/log/traffic: в соответствующих спец-буферах доступны только клавиши их контекстов; отсутствуют локальные define-key вне keyspec.
- Приоритет контекстов:
  - В буфере carriage-mode локальные клавиши перекрывают глобальные при коллизиях (carriage > report/log/traffic > global).
- Новые действия:
  - "C-c e RET" → carriage-send-buffer (в carriage-mode при transient=nil).
  - "C-c e M-RET" → carriage-send-subtree (в carriage-mode при transient=nil).
  - "C-c e e" (global) → carriage-open-buffer (при включённом carriage-global-mode).
- Open-buffer (эфемерный проектный буфер):
  - Создаёт/находит уникальный для проекта буфер с включённым carriage-mode; default-directory — корень проекта.
  - При kill-emacs тест проверяет, что хук предлагает сохранить такие буферы (мокаем пользовательский ответ).

* UI v1.3 — Дополнительные тесты (цвета/иконки/flash/звук/folding)
- Mode-line — окраска состояний:
  - Имитация состояний idle/sending/streaming/error → проверка, что сегмент состояния propertize с лицами:
    - idle → carriage-ui-state-idle-face
    - sending/streaming → carriage-ui-state-sending-face (спиннер наследует тот же face)
    - error → carriage-ui-state-error-face
- Иконки:
  - Commit — при доступном all-the-icons сегмент содержит иконку "git-commit"; при carriage-mode-use-icons=nil — текст [Commit].
  - Intent — Hybrid использует иконку, отличную от Code (merge_type vs code).
  - [Ctx] — иконка "link" для gptel-context; [Files] — без изменений.
  - Suite/Engine — при включённых carriage-mode-use-suite-icon/…-engine-icon показываются как ICON [value]; в текстовом режиме — "Suite: [udiff]" и "Engine: [git]".
- Модель gptel-default:
  - Активная модель "gptel-default" → вызов (carriage-select-model) открывает минибуфер с пустым initial-input; для прочих моделей — предзаполнен полным id.
- Flash патчей:
  - По завершении успешного запроса в исходном org-буфере все блоки «последней итерации» получают временную подсветку на ~carriage-mode-flash-duration секунд; проверка через overlays/pulse (overlays-at не пуст) и автоудаление.
- Звуковое уведомление:
  - При carriage-mode-audio-notify=t:
    - Если carriage-mode-audio-sound — путь к файлу и файл существует → вызывается play-sound-file.
    - Иначе → вызывается beep/play-sound.
  - Заглушка через advice для перехвата вызова без фактического воспроизведения.
- Reasoning folding:
  - После вставки "#+end_reasoning" тело reasoning-блока невидимо (org-fold/invisible overlay); org-cycle раскрывает блок обратно.
#+end_src
