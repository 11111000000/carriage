#+title: Testing v1 — План тестирования
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t

* Цели
- Гарантировать корректность парсеров, dry-run и применения.
- Покрыть позитивные и негативные сценарии, краевые случаи.

* Наборы тестов
** Юнит-тесты (ERT)
- Парсеры:
  - SRE: корректные/некорректные сегменты, директивы #+pair.
  - SRE: превышение лимита пар в sre-batch → SRE_E_LIMITS.
  - SRE: пересинхронизация DELIM → предупреждение SRE_W_DELIM_RESYNC (при успехе), ошибка SRE_E_COLLISION_DELIM (при провале).
  - SRE: :range вне границ → clamp и предупреждение SRE_W_RANGE_CLAMP; одинаковое поведение dry-run/apply.
  - PATCH: многофайловый diff → отказ, /dev/null create/delete, :strip логика.
  - PATCH: rename/copy прелюдии → PATCH_E_RENAME_COPY; бинарные секции → PATCH_E_BINARY.
  - PATCH: превышение размера тела (> 4 MiB) → PATCH_E_LIMITS.
  - MODE: алиасы :op (replace/diff/write/create_file/delete_file/rename_file) — по умолчанию отказ с MODE_E_DISPATCH.

  - File Ops: create/delete/rename — предусловия, :mkdir, :ensure-final-newline, конфликты путей и существование/отсутствие файлов; create: валидация :delim (=6 hex, Emacs regexp \\`[0-9a-f]\\{6\\}\\'), негативный кейс при неверном токене.
- Валидаторы regexp (Emacs flavor): неподдерживаемые конструкции → ошибка.
- Нормализация путей: см. ./security-v1.org.
- TRAMP/remote: см. ./security-v1.org (отказ при (file-remote-p) t).
- NOOP-политика: при carriage-mode-sre-noop-on-zero-matches=t и :occur first с 0 совпадений → статус 'skip и предупреждение.

** Интеграционные
- Тестовый git-репозиторий (временный каталог).
- Apply pipeline:
  - delete → rename → create → patch → sre/sre-бatch порядок.
  - Сбой в середине группы → остановка без автоматического отката.
  - Dry-run отчёты и подтверждение.
  - Асинхронность: запуск carriage-apply-plan-async возвращает управление немедленно; завершение приходит через колбэк; UI/буфер не блокируется (эмуляция таймера).
  - Abort: при отмене активного шага пайплайн завершается корректно; отчёт помечает aborted.
  - Sync-wrapper (single block): синхронное применение patch использует движок (git), отчёт содержит :pid и :elapsed-ms; поведение совпадает с async по статусам.
  - По умолчанию коммита после apply нет; проверить, что история git не меняется без явной commit-команды.
  - При stage-policy='index изменения оказываются в индексе (git diff --cached не пуст).
  - Команды carriage-commit-changes и carriage-commit-last-iteration создают один коммит; проверить набор файлов и шаблон сообщения.
- Движки:
  - Выбор движка (carriage-select-apply-engine) меняет реализацию шагов; заголовочный :apply игнорируется.
  - Для движка 'git: dry-run вызывает git apply --check; apply — git apply [--index].
- gptel-mock: имитация ответа LLM с блоками:
  - Стрим: несколько чанков STRING → t; проверка:
    - UI переходит sending→streaming→idle; спиннер останавливается.
    - В исходном буфере создан «регион ответа» и текст чанков напечатан по мере поступления (сохранение порядка).
    - При (reasoning . TEXT|t) создан и корректно закрыт блок #+begin_reasoning/#+end_reasoning.
  - Ошибка: nil → состояние error, лог и завершение (carriage-transport-complete t); reasoning-блок закрыт.
  - Abort: 'abort → обработчик отмены вызывает gptel-abort; состояние error; reasoning-блок закрыт, регион ответа сброшен.
- echo (dev): без gptel — backend='echo' стримит тестовые чанки, проверяем видимость в *carriage-traffic*, переходы состояний и корректную отмену (abort).

** Золотые документы (golden files)
- Набор org-файлов с известными блоками и ожидаемыми результатами.
- Тесты «без изменений» (идемпотентность).

* Как запускать
- emacs -Q -batch -l ert -l test/run.el -f ert-run-tests-batch-and-exit

* Метрики качества
- Покрытие веток в парсерах и апплаерах.
- Время на dry-run и применение больших файлов (пороговые значения).

* Примитивные фикстуры (elisp-скелеты)
#+begin_src emacs-lisp
(require 'ert)

;; SRE
(ert-deftest carriage-sre-parse-basic ()
  (should (fboundp 'carriage-parse-sre)))

(ert-deftest carriage-sre-occur-all-expect-required ()
  (let ((plan '((:version "1" :op 'sre-batch :file "x"
                  :pairs ((:from "a" :to "b" :opts (:occur all)))))))
    ;; skeleton: expect error on dry-run without :expect
    (should t)))

;; Unified diff
(ert-deftest carriage-diff-parse-one-file ()
  (should (fboundp 'carriage-parse-diff)))

(ert-deftest carriage-diff-git-check-fails ()
  ;; skeleton: simulate git apply --check failure
  (should t))

;; File ops
(ert-deftest carriage-create-validate-and-apply ()
  (should (fboundp 'carriage-parse-create)))

(ert-deftest carriage-delete-validate-and-apply ()
  (should (fboundp 'carriage-parse-delete)))

(ert-deftest carriage-rename-validate-and-apply ()
  (should (fboundp 'carriage-parse-rename)))

;; BUGFIX regression: create :delim — см. ./index.org (FREEZE: ровно 6 lower hex, Emacs anchors)
(ert-deftest carriage-create-delim-validation ()
  (let ((hdr '(:version "1" :op "create" :file "x" :delim "1db651"))
        (bad '(:version "1" :op "create" :file "x" :delim "ZZZZZZ")))
    (should (ignore-errors
              (carriage-parse-create hdr "<<1db651\nok\n:1db651\n" default-directory)))
    (should-error
     (carriage-parse-create bad "<<ZZZZZZ\nok\n:ZZZZZZ\n" default-directory))))

;; Security and env
(ert-deftest carriage-path-normalization ()
  (should t))

(ert-deftest carriage-tramp-detected-and-refused ()
  (should t))

;; UI/report: таблица должна быть валидной org-table и выравниваться
(ert-deftest carriage-report-renders-org-table ()
  (let ((buf (get-buffer-create "*carriage-report*")))
    (with-current-buffer buf
      (org-mode)
      (erase-buffer)
      (insert "| # | op | path | status | matches | details | preview | actions |\n")
      (insert "|---+----+------+--------+---------+---------+---------+---------|\n")
      (insert "| 1 | create | script.js | fail | 0 | Already exists |  | [Ediff] [Apply] |\n")
      (goto-char (point-min))
      (should (org-at-table-p))
      (org-table-align)
      (should (org-at-table-p)))))

;; UI/source buffer: carriage-mode не выключается и буфер остаётся writable
(ert-deftest carriage-mode-persists-and-writable-after-apply ()
  (with-temp-buffer
    (org-mode)
    (carriage-mode 1)
    (let ((before-ro buffer-read-only))
      ;; эмуляция цикла без изменения исходного буфера
      (run-hooks 'post-command-hook)
      (should (bound-and-true-p carriage-mode))
      (should (eq buffer-read-only before-ro)))))
#+end_src
