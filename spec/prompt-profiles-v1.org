#+title: Suites v1 — Intent/Suite и композиция промптов
#+author: Carriage Team
#+language: ru
#+options: toc:2 num:t

* Назначение
- Норматив Intent/Suite для режимов диалога и патчей.
- Шаблоны ответов для форматов v1 (=sre=, =patch=, =create/delete/rename=) определяются через композицию промпт-фрагментов, поставляемых op-модулями.
- Цель: минимизация вариативности, расширяемость через добавление новых :op без правок ядра.

* Термины
- Intent — смысл ответа: Ask (свободный диалог), Code (строго только блоки patch), Hybrid (текст вперемежку с блоками; применяются только блоки).
- Suite — «набор речи»: перечень разрешённых :op и собранный системный промпт из фрагментов соответствующих op-модулей.

* Общие принципы (Intent)
- В Intent=Code модель ДОЛЖНА выдавать только блоки:
  - #+begin_patch (<plist>) … #+end_patch
- В Intent=Hybrid допускается текст вне блоков; парсинг и применение выполняются только для блоков.
- Один блок = одна операция — см. ./index.org (Инварианты v1).
- Переменные окружения (пути, DELIM для create и т.п.) предоставляет инструмент (Carriage); :delim применяется только для create.

* Intent: Ask (диалог)
- Назначение: прояснение требований, сбор контекста.
- Допустим произвольный текст org; запрещены =begin_patch= блоки.
- Рекомендуется завершать ответ «следующими шагами» для перехода к Intent=Code/Hybrid.

* Intent: Code/Hybrid и Suites
** Базовые сьюиты v1
- 'sre — разрешены :op (sre, aibo, create, delete, rename).
- 'udiff — разрешены :op (patch, create, delete, rename).
- Примечание: file-ops (create/delete/rename) разрешены в обоих сьюитах; отдельных 'auto и 'file-ops нет.

** Композиция промпта
- Каждый op-модуль (например, lisp/ops/carriage-op-sre.el) публикует фрагмент промпта и регистрирует parse/dry-run/apply.
- Suite объявляет (:ops-allowed …) и собирает системный промпт как конкатенацию фрагментов разрешённых ops, добавляя строгости для Intent=Code (никакого текста вне блоков; только begin_patch). Для Intent=Hybrid текст вне блоков допускается, но инструмент обрабатывает только блоки.
- Инструмент подставляет пути. Для :op "create" не используются маркеры‑разделители: содержимое файла — это «сырое» тело между #+begin_patch и #+end_patch.


** Общие регуляции
- В Intent=Code ответ содержит ТОЛЬКО блоки =begin_patch/end_patch=; в Intent=Hybrid текст вне блоков допускается и игнорируется при применении.
- Строгое соблюдение грамматики соответствующего формата.
- Пути: см. ./security-v1.org (только относительные; запрет абсолютов и «..»).
- Ключ :apply в заголовке блоков допускается, но игнорируется в v1; фактический движок выбирается конфигурацией (см. ./apply-engines-v1.org).
- Совместимость Suite↔Engine проверяется на запуске: Suite='sre допускает 'emacs|'git; Suite='udiff требует 'git.

* Фрагменты для форматов (встраиваются Suite-ом)
** SRE (1..N пар в одном блоке)
- Шаблон:
  - #+begin_patch (:version "1" :op "sre" :file "RELATIVE/PATH")
  - [опционально: #+pair (<plist>) — опции для СЛЕДУЮЩЕЙ пары]
  - #+begin_from
  - FROM-текст
  - #+end_from
  - #+begin_to
  - TO-текст
  - #+end_to
  - … повторять пары по необходимости …
  - #+end_patch
- Замечания:
  - Intent=Code: ничего вне блока; Intent=Hybrid: текст вне блоков допускается (инструмент применяет только блоки). Сначала begin_from/end_from, затем begin_to/end_to для КАЖДОЙ пары.
  - Если внутри содержимого встречается строка «#+end_from» или «#+end_to», поставь перед ней один пробел.

** AIBO (literal-only, один файл)
- Шаблон:
  - #+begin_patch (:version "1" :op "aibo" :file "RELATIVE/PATH")
  - [опционально: #+pair (<plist>) — опции для СЛЕДУЮЩЕЙ пары]
  - #+begin_from
  - FROM-текст (literal)
  - #+end_from
  - #+begin_to
  - TO-текст (literal)
  - #+end_to
  - … повторять пары при необходимости …
  - #+end_patch
- Замечания:
  - Никаких регулярок; ключ :match запрещён.
  - Допустимы только :occur 'first|'all (при all обязателен :expect), :range и (опционально) :anchor.
  - Идемпотентность: при after==before — шаг помечается 'skip; отчёт включает :matches и :changed-bytes.

** PATCH (unified diff, один файл)
- Шаблон:
  - #+begin_patch (:version "1" :op "patch" :strip 1)
  - <unified diff РОВНО ОДНОГО файла>
  - #+end_patch
- Замечания:
  - Строго соблюдай unified diff; пути a/ и b/ указывают на один и тот же относительный путь.

** FILE OPS (create/delete/rename)
- create:
  - #+begin_patch (:version "1" :op "create" :file "RELATIVE/PATH")
  - СОДЕРЖИМОЕ ФАЙЛА
  - #+end_patch
- delete:
  - #+begin_patch (:version "1" :op "delete" :file "RELATIVE/PATH")
  - #+end_patch
- rename:
  - #+begin_patch (:version "1" :op "rename" :from "OLD/RELATIVE/PATH" :to "NEW/RELATIVE/PATH")
  - #+end_patch

* Стратегии контекста (вставка инструментом)
- Весь документ (C-c M-RET) или поддерево (C-c RET) — инструмент формирует system/prompt с учётом Suite и контекста проекта.
- Усечение при переполнении токенов: сокращать нерелевантные разделы, оставлять критичные примеры.

* Guardrails (минимизация ошибок модели)
- Явные маркеры begin_from/begin_to фиксированы; экранируй строки «#+end_from»/«#+end_to» одним пробелом.
- Не используй :delim в SRE; :delim применяется только для create.
- Мини-шаблон пары: begin_from…end_from → begin_to…end_to.
- Для :occur all обязателен :expect (иначе блок будет отклонён).
- В Intent=Code — запрет текста вне блоков; в Intent=Hybrid — текст допускается, но применяется только содержимое блоков.
- Примеры соответствуют формату; минимум вариативности.
- Запрет на base64 по умолчанию (инструмент делает fallback сам).
- Идемпотентность: шаблоны должны быть устойчивыми к повторному применению (повторный запуск не меняет файл); используйте якоря (\=, ^, $), :range и проверку ближайшего контекста без PCRE-lookbehind; для aibo — только literal + anchor/range.

* Диагностика несоответствия
- Текст вне =patch= → фильтрация/перегенерация (по политике).
- Неизвестные :op/:version → отказ и перегенерация с пояснением.

* Примеры итоговых сообщений (вставка инструментом)
** Patch/SRE (пример)
- Файл: "src/app.py"
- Требуемые замены: …
- Сгенерируй блок согласно шаблону ниже и не добавляй ничего вне него.

- Builder v1 — Intent Registry и сборка промптов
- Язык промптов: всегда один (английский по умолчанию). I18N для промптов не применяется. Возможность замены/расширения обеспечивается конфигурацией (overrides/overlays).
- Источник истины:
  - Фрагменты форматов (:op) публикуются рядом с op-модулями (lisp/ops/*), как STRING или FUNCTION (CTX → STRING).
  - Фрагменты Intent публикуются в реестре интентов (lisp/carriage-intent-registry.el), как STRING или FUNCTION (CTX → STRING).
  - Suite не хранит тексты фрагментов — он только определяет (:ops-allowed ...) и выполняет сборку.

* Источники фрагментов и размещение
- op-модули: lisp/ops/carriage-op-<op>.el экспортируют фрагмент промпта (рекомендуемое имя символа: carriage-op-<op>-prompt-fragment).
- Intent-фрагменты: регистрируются через Intent Registry (см. ниже).
- Guardrails (общие правила) живут в сборщике suite и не зависят от i18n.

* Реестр интентов (Intent Registry v1)
- Назначение: отделить «режим ответа» (Code/Hybrid/Ask) от конкретных Suite/op.
- API (норматив):
  - carriage-intent-register INTENT FRAG — зарегистрировать фрагмент (FRAG ∈ STRING | FUNCTION (CTX → STRING)).
  - carriage-intent-get INTENT → FRAG — получить активный фрагмент (с учётом overrides).
  - carriage-intent-known () → LIST — список известных интентов.
- Семантика:
  - Intent=Code — жёстко: отвечать только блоками begin_patch/end_patch; никакого текста вне блоков.
  - Intent=Hybrid — допускается текст вне блоков; инструмент применяет только содержимое блоков.
  - Intent=Ask — запрет begin_patch; диалог без блоков.

* Конфигурационные оверлеи/оверрайды (без i18n)
- Переменные (defcustom, рекомендуемые ключи):
  - carriage-prompt-suite-overlays :: alist вида ((SUITE . (:ops-allowed (op1 op2 ...))) ...), позволяет переопределить белый список :op без правки suite.
  - carriage-op-fragment-overrides :: alist вида ((OP . FRAG) ...), где FRAG ∈ STRING | FUNCTION (CTX→STRING) — точечная замена фрагмента op.
  - carriage-intent-fragment-overrides :: alist вида ((INTENT . FRAG) ...) — точечная замена фрагмента intent.
- Правила приоритета:
  - intent: overrides > registry.
  - op: overrides > op-модуль.
  - suite: overlays дополняют/заменяют (:ops-allowed) базового suite.
- Пример (Elisp, конфиг):
  #+begin_src emacs-lisp
  (setq carriage-prompt-suite-overlays
        '((sre . (:ops-allowed (sre create delete rename)))
          (udiff . (:ops-allowed (patch create delete rename)))))

  (setq carriage-intent-fragment-overrides
        '((Code . "Answer ONLY with Org begin_patch blocks…")
          (Hybrid . (lambda (ctx) "You MAY include prose, but tool applies ONLY patch blocks…"))))

  (setq carriage-op-fragment-overrides
        '((sre . "Use SRE v1: begin_from→begin_to pairs; no :delim; one file per block.")
          (patch . "Use unified diff of EXACTLY ONE file; headers ---/+++; strip=1.")))
  #+end_src

* Алгоритм сборки (pure function)
- Вход: Intent, Suite, CTX (содержит :payload, :context-text?, :context-target?, :files, :delim и прочие переменные окружения).
- Шаги:
  1) ops0 ← базовый список suite (:ops-allowed); ops ← применить carriage-prompt-suite-overlays.
  2) fragments ← по каждому op∈ops:
     - frag ← carriage-op-fragment-overrides[op] || registry(op)  ; STRING|FN
     - если FN — вычислить (FUNCALL FN CTX); собрать в список строк.
  3) intent-note ← carriage-intent-fragment-overrides[intent] || carriage-intent-get(intent); если функция — вычислить по CTX.
  4) guardrails ← статический текст правил:
     - Имя блока: только begin_patch/end_patch (никаких алиасов).
     - Пути: только относительные; запрет «..», абсолютов, TRAMP.
     - Для :op \"create\" не используются маркеры‑разделители (<<DELIM/:DELIM); содержимое файла — это всё тело блока между begin/end.
     - Suite=sre: разрешены только (sre create delete rename) и никакого unified diff.
     - Suite=udiff: разрешены только (patch create delete rename) и никакого begin_from/begin_to.
     - Intent=Code: запрет текста вне блоков; Intent=Hybrid: текст допускается, применяется только содержимое блоков.
     - Запрещены «случайные» строки вида \"#+end\" внутри блока; блок должен закрываться только точной строкой \"#+end_patch\".
     - Никогда не печатать строку \"#+CARRIAGE_ITERATION_ID: …\" — её вставляет инструмент.
  5) system ← guardrails + intent-note + join(fragments, "\n\n") + (опционально перечисление разрешённых :op).
  6) prompt ← CTX :payload (+ опционально :context-text в ветку, указанную :context-target).
  7) fingerprint ← строка вида ";; fingerprint: <SHA1(system)>" добавляется в конец system для диагностики дрейфа промпта; UI/отчёт могут отображать несовпадение версий.
- Выход: plist {:system STRING :prompt STRING} (или совместимая структура транспорта).

* Защитные проверки (asserts)
- После сборки system выполнить быстрые проверки отсутствия «чужих форматов»:
  - Для Suite='sre — отсутствуют маркеры unified diff: "^---\\s-+a/|^\\+\\+\\+\\s-+b/|^diff --git" и тексты "unified diff".
  - Для Suite='udiff — отсутствуют маркеры SRE: "#\\+begin_from"|"#\\+begin_to" и тексты "begin_from/begin_to".
- Неизвестные :op в ops → MODE_E_DISPATCH (dev-режим) или пропуск с логом (prod-политика).
- Размер итогового system ограничен лимитами FREEZE (см. ./index.org).

* Тестирование и соответствие
- Юниты на сборщик (см. ./testing-v1.org):
  - Suite=sre: system не содержит упоминаний unified diff/+++ ---/diff --git.
  - Suite=udiff: system не содержит begin_from/begin_to.
  - Intent=Code: присутствует жёсткое правило «только begin_patch».
  - Overrides: при установке carriage-op-fragment-overrides/intent-... используются переопределённые строки/функции.
- Интеграция:
  - gptel-mock: проверка, что ответ, сгенерированный под Suite, удовлетворяет guardrails.
- Расширяемость:
  - Новые :op добавляются регистрацией op-модуля и публикацией его фрагмента; Intent — регистрацией в Intent Registry.
