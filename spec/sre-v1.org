#+title: Search/Replace (SRE) v1 Specification
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t
#+property: header-args :results silent

* Назначение и охват
- Определяет формат поисково-заменяющих патчей (SRE) для Carriage-mode.
- Цель: простой, надёжный, удобно редактируемый в Org и легко генерируемый даже слабой LLM.
- Принцип: один внешний Org-блок = одна целевая сущность (обычно один файл); внутри — 1..N пар FROM→TO.
- Версия спецификации: "1" (далее — v1).

* Термины
- Блок patch — специальный Org-блок вида:
  - #+begin_patch (<plist>) ... #+end_patch
- Пара (pair) — два последовательно заданных спецблока: первый — FROM, второй — TO.
- FROM/TO — «спецблоки» Org: #+begin_from … #+end_from и #+begin_to … #+end_to.
- Директива #+pair — строка с plist-опциями для ближайшей следующей пары. Других директив не предусмотрено.

* Общее устройство блока SRE
** Заголовок (обязательные ключи)
Блок должен начинаться строкой:
- #+begin_patch (:version "1" :op "sre" :file "relative/path")
и завершаться:
- #+end_patch

Ключи заголовка:
- :version — строка "1".
- :op — ровно "sre" (одна или несколько пар в одном блоке).
- :file — относительный путь к файлу внутри корня проекта.
- Примечание: :delim в SRE v1 не используется.

** Тело блока (грамматика и элементы)
Внутри patch-блока допустимы:
- Комментарии для человека — игнорируются парсером.
- Директива пары:
  - Строка "#+pair (<plist>)" — опции для СЛЕДУЮЩЕЙ пары FROM→TO.
- Пары замен (строгая последовательность «from → to»):
  - #+begin_from [PLIST?]
    FROM-пayload
    #+end_from
  - #+begin_to [PLIST?]
    TO-пayload
    #+end_to

Дефолты опций пары:
- :occur first, :match literal; без :range и без :expect.
- При :occur all обязателен :expect ≥ 0.

Экранирование внутри блоков:
- Если в содержимом нужна строка, равная «#+end_from» или «#+end_to», она записывается с одним ведущим пробелом.
- Парсер при извлечении контента снимает этот один пробел только у ровной строки «#+end_from»|«#+end_to».

** Формальная грамматика (EBNF, упрощённо)
patch-block   := patch-header newline patch-body patch-footer
patch-header  := "#+begin_patch" ws plist newline
patch-footer  := "#+end_patch" newline?
plist         := "(" ws kv-pair (ws kv-pair)* ws ")"
kv-pair       := ":"symbol ws value
value         := string | number | symbol | list
list          := "(" (value (ws value)*)? ")"
ws            := space-or-tab*

Обязательные ключи:
  :version "1"
  :op "sre"
  :file "relative/path"

patch-body    := (comment | pair-directive | from-block to-block)*
comment       := любая иная строка
pair-directive:= "#+pair" ws plist newline
from-block    := "#+begin_from" plist? newline payload "#+end_from" newline?
to-block      := "#+begin_to"   plist? newline payload "#+end_to"   newline?
payload       := любая строка; спец-случай экранирования см. выше

* Семантика поиска/замены
** Область поиска
- По умолчанию — весь файл.
- Если указано :range (:start-line N :end-line M) — поиск ограничивается включительно.
- Политика :range: при выходе за границы файла диапазон клампится к [1..N] и этот «эффективный диапазон» повторно используется и в dry-run, и в apply (SRE_W_RANGE_CLAMP).

** Соответствие
- :match literal — точная подстрока.
- :match regex — Emacs regexp (многострочность допускается); неподдерживаемые конструкции → ошибка SRE_E_REGEX_SYNTAX.

** Выбор вхождений
- :occur first — заменяется первое найденное вхождение.
- :occur all — заменяются все неперекрывающиеся; :expect обязателен.
- :expect K — ожидаемое число замен; при несовпадении — отказ в dry-run.

** Идемпотентность
- Выполняется один проход по файлу; дополнительных проходов нет.

* Парсинг (нормативно)
** Алгоритм
- Проверить :version="1", :op="sre", валидировать и нормализовать :file (внутри корня).
- pending-opts ← nil; pairs ← [].
- Сканировать тело сверху вниз:
  - "#+pair (<plist>)" → pending-opts ← plist.
  - "#+begin_from" → читать до "#+end_from" (с экранированием); last-from ← payload.
  - "#+begin_to" при наличии last-from → читать до "#+end_to"; сформировать opts ← defaults ∪ pending-opts; pairs.push({from,to,opts}); сбросить pending-opts и last-from.
  - Иные строки игнорируются.
- Завершение:
  - last-from ≠ nil → SRE_E_UNPAIRED.
  - pairs пуст → SRE_E_SEGMENTS_COUNT (нет пар).

** Диагностика
- SRE_E_VERSION, SRE_E_OP, SRE_E_PATH — неверные заголовки/пути.
- SRE_E_SEGMENTS_COUNT — нет ни одной пары.
- SRE_E_UNPAIRED — найден from без последующего to.
- SRE_E_UNCLOSED_BLOCK — пропущен "#+end_from"/"#+end_to".
- SRE_E_OCCUR_EXPECT — :occur all без :expect.
- SRE_E_REGEX_SYNTAX — неподдерживаемый regexp.
- SRE_E_LIMITS — превышены лимиты (см. FREEZE).
- SRE_W_RANGE_CLAMP — :range скорректирован к границам файла.

* Применение (нормативно)
** Dry-run
- Учитывать :occur, :match, :range; при :occur all — проверять :expect.
- Предпросмотр: мини-дифф по каждой паре; суммарное количество совпадений.

** Применение
- Пары применяются последовательно; каждая пара видит результат предыдущих замен.
- Политики git/индексации/подтверждения — см. ./apply-pipeline-v1.org и ./git-integration-v1.org.

* Безопасность и ограничения
- Политики пути, symlink, TRAMP, EOL/Unicode — см. ./security-v1.org.
- Регулярные выражения — Emacs-flavor; неподдерживаемые конструкции → SRE_E_REGEX_SYNTAX; явные запреты: lookbehind (?<=, ?<!), atomic group (?>), branch reset (?|).
- FREEZE (лимиты): макс. пар в SRE-блоке — 200; макс. payload одной стороны — 512 KiB; макс. размер тела ответа — 4 MiB.

* Рекомендации по промпту (Intent Code/Hybrid / Suites)
- Для Intent=Code: отвечай ТОЛЬКО блоками =begin_patch=; для Intent=Hybrid: допускается текст вне блоков, но парсинг и применение выполняются только для блоков:
  - #+begin_patch (:version "1" :op "sre" :file "RELATIVE/PATH")
  - [опционально: #+pair (<plist>) — для СЛЕДУЮЩЕЙ пары]
  - #+begin_from
  - FROM-текст
  - #+end_from
  - #+begin_to
  - TO-текст
  - #+end_to
  - … повторять пары при необходимости …
  - #+end_patch
- Если в содержимом встречается строка «#+end_from»/«#+end_to», поставьте перед ней один пробел.

* Примеры
** Одна пара (дефолтные опции)
#+begin_patch (:version "1" :op "sre" :file "src/foo.el")
#+begin_from
(defun foo
#+end_from
#+begin_to
(defun foo-v2
#+end_to
#+end_patch

** Несколько пар с опциями
#+begin_patch (:version "1" :op "sre" :file "src/app.py")
#+pair (:occur first)
#+begin_from
LOGGER.info(
#+end_from
#+begin_to
LOGGER.debug(
#+end_to

#+pair (:occur all :expect 3 :match regex)
#+begin_from
\btimeout\s/=\s*30\b
#+end_from
#+begin_to
timeout=60
#+end_to
#+end_patch

** Диапазон строк (:range) и экранирование концов блоков
#+begin_patch (:version "1" :op "sre" :file "docs/guide.org")
#+pair (:range (:start-line 10 :end-line 20))
#+begin_from
  #+end_from
#+end_from
#+begin_to
  #+end_to
#+end_to
#+end_patch
; Парсер снимет один ведущий пробел у ровной строки "#+end_from"/"#+end_to" в содержимом.

* Архитектурные принципы
- Один блок — один файл; внутри — 1..N пар «begin_from → begin_to».
- Жёсткая парность: всегда from→to; любые отклонения — явные ошибки.
- Никакого DELIM в SRE v1 (DELIM остаётся для create).
- Детерминированный разбор без вложенных структур; #+pair влияет только на следующую пару.

* Инварианты и контракты
- Минимум одна пара FROM→TO.
- :occur all → :expect обязателен.
- Комментарии и произвольные строки между парами не влияют на семантику.
- Парсер не модифицирует содержимое; apply выполняет замену последовательно.

* План внедрения

* Имя спец-блока
- Источник истины по имени спец-блока: см. ./parser-registry-v1.org.



