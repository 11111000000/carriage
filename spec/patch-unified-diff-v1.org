#+title: Unified Diff Patch v1 Specification
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t
#+property: header-args :results silent

* Назначение и охват
- Определяет формат патчей на основе unified diff для Carriage-mode.
- Цель: максимально совместимая с git apply форма, пригодная для сложных правок, когда SRE недостаточен.
- Версия спецификации: "1" (далее — v1).

* Принципы
- Один блок = патч для одного файла (жёсткое ограничение v1).
- Дифф должен быть валиден и применим командой "git apply --check".
- Без лишнего текста вне диффа: тело блока — чистый unified diff.

* Устройство блока
** Заголовок
- #+begin_patch (:version "1" :op "patch" :strip 1)
  - :version — строка "1".
  - :op — "patch".
  - :strip — параметр для отбрасывания компонент пути, по умолчанию 1 (ожидаются префиксы a/ и b/).
  - :apply — если присутствует, игнорируется реализацией v1; фактический движок задаётся настройкой.

- #+end_patch — конец блока.

Опциональные ключи:
- :strip integer — переопределение значения по умолчанию 1 (см. ниже).

** Тело блока (unified diff)
- Строго стандартный unified diff, обозревающий изменения одного файла.
- Формат заголовков:
  - Первая пара строк:
    - --- a/relative/path
    - +++ b/relative/path
  - Пути должны указывать на один и тот же файл (относительно корня), различаясь только префиксом a/ → b/.
- Ханки в формате:
  - @@ -L1,Len1 +L2,Len2 @@
  - Далее строки с префиксами:
    - " " (пробел) — неизменённая строка (контекст)
    - "-" — удалённая строка
    - "+" — добавленная строка
- Для создания нового файла допускается вид:
  - --- /dev/null
  - +++ b/relative/path
- Для удаления файла:
  - --- a/relative/path
  - +++ /dev/null
- Ренеймы в v1 не поддерживаются (используйте отдельный :op "rename").

* Ограничения и допущения
- Ровно один файл на блок (исключение: create/delete через /dev/null).
- Политика путей: см. ./security-v1.org.
- Git-apply сам управляет EOL и бинарными частными случаями; в v1 бинарные патчи не поддерживаются (diff — текстовый).

* Парсинг и валидация
** Шаги парсинга
1) Проверить заголовок: :version="1", :op="patch". Ключ :apply, если присутствует, игнорируется (информационный).
2) Извлечь тело; убедиться, что оно содержит корректные строки "--- ..." и "+++ ...".
3) Извлечь пути a/... и b/... (или /dev/null); проверить:
   - Нет абсолютных путей и "..".
   - Если оба пути заданы (не /dev/null), то они ссылаются на один и тот же относительный путь.
4) Убедиться, что тело относится ровно к одному файлу (нет повторных "---/+++" пар). При нарушении — ошибка PATCH_E_MULTI_FILE.
5) Завершить валидацию структуры диффа.

** Dry-run
- Выполнить "git apply --check --directory=<repo-root> --verbose [--reject]" с учётом :strip.
- Если проверка не прошла — сообщить причину (контекст не найден, конфликт и т.д.) и добавить запись в :messages с кодом PATCH_E_GIT_CHECK (stderr/stdout).

** Применение
- Вызвать активный движок применения (см. ./apply-engines-v1.org) для операции 'patch.
  - Движок 'git по умолчанию: "git apply --directory=<repo-root> [-p strip] [--index при policy='index]".
- Опционально проиндексировать файл согласно политике стадирования; коммит не выполняется в рамках apply.
- Коммит — отдельное действие пользователя (например, общей командой после группы правок).


* Безопасность
- Жёсткая фильтрация путей: запрет абсолютных, запрет выхода за корень, отказ на подозрительных конструкциях.
- Не использовать "--unsafe-paths".
- Для больших патчей — отображать предпросмотр и требовать подтверждение.
- Жёсткий лимит размера тела патча: 4 MiB; при превышении — ошибка PATCH_E_LIMITS (см. ./errors-v1.org).

* Рекомендации по промпту (для режима Code)
- Отвечай только блоками Org формата patch:
  - #+begin_patch (:version "1" :op "patch" :strip 1)
  - <unified diff РОВНО ОДНОГО файла>
  - #+end_patch
- Требования:
  - Строго соблюдай синтаксис unified diff.
  - Пути должны начинаться с a/ и b/ и указывать на один и тот же относительный путь.
  - Не добавляй комментарии вне блока.

* Примеры
** Изменение существующего файла
#+begin_patch (:version "1" :op "patch" :strip 1)
--- a/src/foo.el
+++ b/src/foo.el
@@ -10,1 +10,1 @@
-(defun foo
+(defun foo-renamed
#+end_patch

** Создание нового файла
#+begin_patch (:version "1" :op "patch" :strip 1)
--- /dev/null
+++ b/docs/intro.md
@@ -0,0 +1,3 @@
+* Intro
+Welcome to Carriage.
+Enjoy.
#+end_patch

** Удаление файла
#+begin_patch (:version "1" :op "patch" :strip 1)
--- a/tmp/old.log
+++ /dev/null
@@ -1,3 +0,0 @@
-foo
-bar
-baz
#+end_patch

* Совместимость и эволюция
- v1 ограничивает патч одним файлом. В v1.1 возможно добавление "multi-file patch" с явным перечислением файлов или множеством блоков.
- Ренеймы в v1 — отдельная операция (:op "rename") вне unified diff.
- Парсер должен отвергать неизвестные :version; обратная совместимость — обязательна.

* Архитектурные принципы
- Максимальная опора на стандарт: тело — валидный unified diff; проверка и применение — через git apply.
- Минимальный заголовок:
  - :op "patch", :strip 1 (по умолчанию); ключ :apply (если присутствует) игнорируется реализацией v1.

- Один блок — один файл:
  - Валидация отвергает множественные "---/+++" пары в одном блоке.
  - Создание/удаление — через /dev/null, переименования — отдельной операцией.
- Детерминированность и безопасность:
  - Жёсткая фильтрация путей (относительные, без "..", без абсолютных).
  - Никакого текстового “шума” вокруг диффа; только строка заголовка Org и сам diff.
- Разделение ответственности:
  - Парсер: извлечь пути, проверить однопоточность файла, вызывать dry-run git apply --check.
  - Апплаер: выполнять git apply [--index] и, при необходимости, индексацию; без коммита; показывать предпросмотр.
- Человеко-дружественность:
  - Привычный вид диффа; удобно читать, рецензировать и сравнивать.
  - Внешний carriage-блок — единица сворачивания/применения в Org.

* Базовые принципы формата (Дао)
- Стандарт важнее самодельности: используем проверенный формат diff.
- Простая рамка — строгие правила: никаких дополнительных маркеров внутри диффа.
- Один файл — одна мысль: легче анализ и откат.
- Сначала проверка, потом действие: dry-run git apply --check обязателен.
- Чистые пути — чистая совесть: строгая нормализация и отказ на подозрительных путях.

* Инварианты и контракты
- Заголовки "--- a/…", "+++ b/…" (или /dev/null) указывают на один и тот же относительный путь.
- В блоке разрешена только одна пара заголовков "---/+++".
- :strip = 1 по умолчанию; допускается переопределение, если префиксы путей иные.
- Разрешены стандартные строки Git (diff --git, index, * file mode, similarity index); прочие посторонние строки — ошибка.
- При ошибке git apply --check — патч не применяется.

* Мини-псевдокод валидатора
- Проверить header (:version="1", :op="patch"). Ключ :apply, если встречается, игнорировать.
- Найти строки "--- ..." и "+++ ..."; извлечь пути.
- Верифицировать, что ровно один файл затронут; пути относительные и без "..".
- Выполнить "git apply --check"; собрать stderr/stdout для отчёта.

* Матрица минимальных тестов
- Базовые:
  - Изменение существующего файла (один ханк).
  - Создание файла (/dev/null → b/…).
  - Удаление файла (a/… → /dev/null).
- Ошибки:
  - Две и более пар "---/+++" в одном блоке.
  - Абсолютный путь или “..” в пути.
  - Несогласованные пути a/... и b/... (разные файлы).
  - Сбой "git apply --check" (контекст не найден).

* Имя спец-блока
- Источник истины: см. ./parser-registry-v1.org.
- В v1 используется только begin_patch/end_patch; алиасы не поддерживаются.

* Дополнительные нормы v1 (разъяснения)

** Допуск «прелюдий» git-diff
- В теле unified diff разрешены стандартные строки-предисловия Git:
  - diff --git a/path b/path
  - index <hex>..<hex> <mode>
  - new file mode <mode>
  - deleted file mode <mode>
  - similarity index <N>% (только как информативная строка; при наличии признаков rename/copy — отказ)
- Любые признаки переименования/копирования (rename from/to, copy from/to) в v1 запрещены; такой блок должен быть отвергнут с кодом PATCH_E_RENAME_COPY.
** Политика :strip и префиксов путей
- В v1 пути должны иметь префиксы a/ и b/; значение :strip по умолчанию 1.
- Явно указанное :strip имеет приоритет, но должно соответствовать префиксам путей; при несоответствии — PATCH_E_STRIP.

** Концы строк и «No newline at end of file»
- Сообщения вида “No newline at end of file” допускаются как часть unified diff и обрабатываются git apply.
- Инструмент должен отображать это в предпросмотре и не добавлять перевод строки, если его не было.
- Нормализация EOL через :eol обычно не требуется; если указана, инструмент может предупредить о возможных последствиях.

** Ограничения на бинарные секции
- Бинарные патчи в v1 запрещены. Наличие следующих секций — повод для отказа с кодом PATCH_E_BINARY:
  - GIT binary patch
  - Binary files differ
- Поддержка бинарей возможна в будущих версиях отдельной спецификацией.

** Дополнительные примеры с прелюдиями Git

Изменение одного файла с заголовками diff --git:

#+begin_patch (:version "1" :op "patch" :apply "git-apply" :strip 1)
diff --git a/src/foo.el b/src/foo.el
index 3c1a5b2..9f0a7c1 100644
--- a/src/foo.el
+++ b/src/foo.el
@@ -10,1 +10,1 @@
-(defun foo
+(defun foo-renamed
#+end_patch

Создание нового файла (через /dev/null) с new file mode:

#+begin_patch (:version "1" :op "patch" :apply "git-apply" :strip 1)
diff --git a/docs/intro.md b/docs/intro.md
new file mode 100644
--- /dev/null
+++ b/docs/intro.md
@@ -0,0 +1,3 @@
+* Intro
+Welcome to Carriage.
+Enjoy.
#+end_patch

Удаление файла (deleted file mode допускается):

#+begin_patch (:version "1" :op "patch" :apply "git-apply" :strip 1)
diff --git a/tmp/old.log b/tmp/old.log
deleted file mode 100644
--- a/tmp/old.log
+++ /dev/null
@@ -1,3 +0,0 @@
-foo
-bar
-baz
#+end_patch

** Чек-лист соответствия (дополняет раздел «Матрица минимальных тестов»)
- Ровно один файл на блок (одна пара ---/+++).
- Пути относительные; нет абсолютов и «..».
- Разрешены строки diff --git/index/* file mode; но нет rename/copy/binary секций.
- :strip согласован с префиксами путей (a/ b/ → 1; иначе → 0 или явное).
- Dry-run: git apply --check обязателен; при отказе — вывести причину.

* Формальная грамматика (EBNF)
#+begin_src text
patch-block    := patch-header newline diff-body patch-footer
patch-header   := "#+begin_patch" ws plist newline
patch-footer   := "#+end_patch" newline?
plist          := "(" ws kv-pair (ws kv-pair)* ws ")"
kv-pair        := ":"symbol ws value
value          := string | number | symbol | list
list           := "(" (value (ws value)*)? ")"
ws             := space-or-tab*

Обязательные ключи:
  :version "1"
  :op "patch"
Опциональные ключи:
  :strip integer
  :apply "git-apply"   ; допускается в заголовке, но игнорируется реализацией v1
  
diff-body := unified-diff одного файла:
  - первая пара заголовков --- X и +++ Y
    X ∈ {/dev/null, a/relpath}, Y ∈ {b/relpath, /dev/null}
  - ≥1 ханка с префиксами ' ' (контекст), '-' (удалено), '+' (добавлено)
