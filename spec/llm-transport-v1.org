#+title: LLM Transport v1 — Абстракция запросов к LLM и агентам
#+author: Carriage Team
#+language: ru
#+options: toc:2 num:t

* Назначение
- Определить транспортный слой для диалога с LLM/агентами, независимый от конкретной библиотеки.
- Позволить использовать gptel как «адаптер по умолчанию» без зашивки его API в остальной код.
- Обеспечить возможность замены транспорта (JSON-RPC/Agent, MCP и т.п.) без изменений UI/пайплайна.

* Цели
- Единый контракт «запрос → события → завершение».
- Поддержка: потокового ответа, reasoning-блоков, tool-use (функциональные вызовы), медиа и контекста.
- Декларация возможностей (capabilities), чтобы UI и промпты адаптировались к бэкенду.
- Совместимость с gptel (через адаптер) и с агентами (JSON-RPC/MCP).

* Термины
- Транспорт (Transport) — реализация интерфейса ниже (Elisp функции/генерики).
- Бэкенд (Backend) — конкретный провайдер/агент (OpenAI, Ollama, внешний агент и т.д.).
- FSM — конечный автомат, управляющий запросом (инициатива транспорта), совместим по идее с gptel.

* Интерфейс (норматив, Elisp-уровень)
** Основные вызовы
- carriage-llm-request SPEC CALLBACK → FSM
  - Инициировать запрос по спецификации SPEC.
  - CALLBACK вызывается многократно по мере событий (см. «События»), сигнатура:
    (funcall CALLBACK EVENT INFO)
- carriage-llm-abort FSM|BUFFER — прервать активный запрос.

- Результат carriage-llm-request — объект FSM (или plist), содержащий INFO:
  :buffer BUF, :position MARK, :backend BACKEND, :model SYMBOL|STRING, :stream t|nil, ...
  INFO расширяем: транспорт может добавлять собственные ключи.

** Спецификация запроса (SPEC, plist)
- Ключи (минимум):
  - :backend BACKEND-OBJ|SYMBOL — активный бэкенд транспорта.
  - :model SYMBOL|STRING — имя модели для BACKEND.
  - :stream t|nil — потоковый режим (при поддержке бэкенда).
  - :system STRING|LIST|FUNCTION — системное сообщение/шаблон (как в gptel).
  - :messages VECTOR|LIST — история диалога (если уже сформирована).
  - :prompt STRING|LIST — альтернатива :messages (краткая форма).
  - :context LIST — дополнительные источники (буферы/файлы/оверлеи/медиа).
  - :tools LIST — набор инструментов (см. «Tool-use»).
  - :schema JSON|PLIST|STRING — схема структурированного ответа (если поддерживается).
  - :transforms LIST — функции трансформации запроса (опционально).
  - :position MARKER|INT, :buffer BUF — где отрисовывать/привязывать взаимодействие.

- Правила:
  - Если :messages отсутствует, транспорт собирает её из :prompt и :system.
  - :context может быть включён в system/user часть по политике (см. ui-v1.org).
  - Транспорт обязан не менять глобальные переменные (локальность значений).

** События (EVENT)
- Строка/символ для статуса:
  - " Typing..." | " Waiting..." — статусы для UI (опционально).
- Потоковые/финальные данные:
  - STRING — фрагмент основного текста ответа (streaming).
  - t — признак завершения потоковой передачи (успех).
  - nil — ошибка/нет ответа (см. INFO :status/:error).
- Специальные пары:
  - (reasoning . TEXT|t) — блок «мыслей» (вставлять/игнорировать по настройке).
  - (tool-call . ((TOOL ARGS CB) ...)) — запрос на запуск инструментов.
  - (tool-result . ((TOOL ARGS RESULT) ...)) — результат запущенных инструментов.
  - abort — запрос/передача отменена пользователем.

- INFO (передаётся второй аргумент CALLBACK):
  - :status STRING — «HTTP ...» или человекочитаемая строка статуса.
  - :error PLIST|STRING — детали ошибки, если есть.
  - :reasoning STRING — накопленный reasoning (необязательно).
  - :include-reasoning t|ignore|STRING — политика вставки reasoning.
  - :tools — активные инструменты (см. ниже).
  - :data — внутреннее представление запроса (для диагностики).
  - Допускаются расширения для конкретных бэкендов.

** Инструменты (Tool-use)
- Формат инструмента (struct или plist):
  - :name STRING — имя
  - :function FN — функция-исполнитель (синхронная/асинхронная)
  - :args LIST — спецификация аргументов (JSON-schema-подобная)
  - :async t|nil, :confirm t|nil|FN, :include t|nil

- Событие (tool-call . ((TOOL ARGS CB) ...)):
  - Хост (Carriage) решает, запускать ли инструмент (confirm/auto).
  - Для async-функций FN вызывается как (FN CB-RESULT ...ARGS).
  - Результат возвращается в транспорт через (tool-result . ...), который повторно отправляется в LLM (если требуется бэкендом).

** Способности бэкенда (capabilities)
- BACKEND описывает:
  - :capabilities — список символов: (stream tool-use media url json nosystem reasoning ...)
  - :mime-types — поддерживаемые типы медиа (для media/url).
  - :request-params — бэкенд-специфичные параметры.
  - :header/:url|:curl-args — низкоуровневые детали (если есть).
- Транспорт проверяет способности и деградирует корректно:
  - Нет stream — объединённая передача (без частичных событий).
  - Нет tool-use — игнор событий инструментов (или ошибка).
  - Нет media — только текст.

* Адаптер к gptel (референс)
- Транспорт «gptel-adapter» должен:
  - Конвертировать SPEC → gptel-request (map полей).
  - Переводить поток gptel в события (STRING, t, nil; reasoning, tool-call, tool-result).
  - Поддерживать :context (буферы/файлы/медиа) через gptel-context.
  - Передавать :schema в gptel (response_format/json schema).
  - Обеспечивать gptel-curl|url пути, логгирование, fsm.
- Сопоставление:
  - :system, :messages/:prompt → gptel директивы/список сообщений.
  - :stream → gptel-stream (при capability).
  - :tools → gptel-tools (функции/категории).
  - :schema → gptel--parse-schema.
  - reasoning → (reasoning . text|t).
  - tool-use → (tool-call . ...), (tool-result . ...).

* Агентный транспорт (JSON-RPC v1, эскиз)
- Цель: запуск внешнего агента (локальный процесс/сервер) по JSON-RPC 2.0.
- Методы:
  - llm.complete — запрос без стрима → { text, reasoning?, tool_calls? }
  - llm.stream — потоковый режим → события: onText(text), onReasoning(text), onToolCall(...), done.
  - tool.run — запуск инструмента локально/удалённо (по политике Carriage); результат возвращается в агент транспортом через callback.
- Сообщения (минимум):
  - request: { model, system?, messages|prompt, context?, tools?, schema?, options{stream} }
  - events: { type: "text"|"reasoning"|"tool_call"|"tool_result"|"done"|"error", data: ... }
- Безопасность:
  - Никаких file:// операций по умолчанию; контент — строками или data:URL (по политике).
  - Разделение привилегий: инструменты исполняются на стороне Carriage (или с confirm).

* Интеграция с UI/пайплайном
- UI (ui-v1.org) принимает события транспорту и обновляет:
  - header-line/mode-line (статусы, спиннеры) на основании " Waiting..."|"Typing..." и пр.
  - reasoning-блоки — по политике :include-reasoning.
  - tool-call — предлагает подтверждение и запускает инструменты.
- Apply-пайплайн не зависит от транспорта: он начинает работать, когда получены и приняты патч-блоки.

* Ошибки (LLM_E_*)
- Рекомендуемые коды (дополнятся в errors-v1.org при внедрении):
  - LLM_E_BACKEND — бэкенд недоступен/неизвестен
  - LLM_E_REQUEST — ошибка при формировании запроса
  - LLM_E_STREAM — ошибка потоковой передачи
  - LLM_E_TOOL_USE — ошибка протокола tool-use
  - LLM_E_SCHEMA — ошибка обработки схемы
- Транспорт обязан декорировать :error и :status (в INFO), не кидая «сырых» исключений наружу (кроме внутренних assert-ошибок).

* Безопасность и изоляция
- Транспорт не модифицирует глобальные Emacs-переменные (только локально).
- TRAMP/remote — по политике проекта (обычно отключено).
- Контент контекста (файлы/оверлеи) должен быть копирован в запрос, не передаваться как путь (если бэкенд не доверенный).

* Тестирование
- Юнит: мок транспорта (эмуляция событий), проверка UI-реакций.
- Интеграция: адаптер gptel → реальные стримы, tool-use, reasoning.
- Агентный транспорт: JSON-RPC петля (вспомогательный скрипт), проверка событий и tool-use.

* Эволюция (v1 → v1.1)
- Добавить: отчёт стоимости токенов, централизованное логгирование запросов/ответов, метрики.
- MCP совместимость: зарегистрировать/подключить источники инструментов.
