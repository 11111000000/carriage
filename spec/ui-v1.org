#+title: UI v1 — Клавиши, header-line, mode-line, отчёты
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t

* Назначение
- Норматив интерфейса пользователя: навигация, применение, визуализация.

* Keymap (org-mode только)
Примечание: начиная с UI v1.1, все команды Carriage должны иметь префикс C-c e и описываются централизованно через keyspec (см. ./keyspec-v1.org). Ниже приведённые сочетания — легаси и могут поддерживаться для совместимости.

- C-c M-RET — отправить весь документ (поведение зависит от Intent: Ask|Code|Hybrid).
- C-c RET — отправить текущее поддерево.
- C-c C-c — dry-run → подтверждение → применить блок =patch= под точкой; при активном регионе — применить все patch-блоки в регионе.
- C-c ! — применить последнюю серию патчей (последняя итерация) — аналог C-c e A.
- C-c e A — применить все блоки из «последней итерации» (строго: без метки — отказ).
- C-c ? — только dry-run текущего блока (или всей «последней итерации» при префикс-аргументе).
- M-n / M-p — навигация по блокам =patch=.
- C-c b c — создать/перейти на ветку carriage/WIP.
- C-c b l — показать лог применений (буфер лога).
- C-c b t — показать трафик LLM (буфер трафика).
- C-c b L — открыть лог и трафик одновременно в правых боковых окнах.
- C-c b r — откат последнего коммита (soft reset).
- C-c b m — выполнить коммит всех изменений (проиндексирует по политике при необходимости).
- C-c b i — выполнить коммит файлов «последней итерации».
- C-c b e — выбрать движок применения (Apply Engine).

* Header-line
- Состав: project-name → buffer-name → org-outline-path.
- Сокращение длинных сегментов многоточием в середине.
- Клики (опционально): переход к заголовку, раскрытие/сворачивание узла.

* Mode-line
- Сегменты и кнопки (кликабельно; без мыши — дублируются командами/клавишами):
  - Intent: [Ask|Code|Hybrid] — переключение намерения ответа (toggle).
  - Suite: [sre|udiff] — выбор набора допустимых операций/шаблонов.
  - Модель: [MODEL] — выбор модели (в модлайне показывается только имя модели).
  - Состояние: [idle|sending|streaming|dry-run|apply|error] + индикатор-спиннер для sending/streaming.
  - Управление циклом:
    - [Dry] — запустить dry-run под точкой (C-c ?).
    - [Apply] — dry-run → подтверждение → применить под точкой; при активном регионе — применить все patch-блоки в регионе (группа) (C-c C-c).
    - [All] — применить все блоки «последней итерации» (C-c e A).
    - [Abort] — отменить текущий запрос/применение (отмена запроса к LLM/пайплайна).
    - [Report] — открыть буфер отчёта (C-c b l).
  - Просмотр:
    - [Diff] — показать мини-дифф текущего блока (если доступен).
    - [Ediff] — открыть ediff для текущего файла/патча.
  - Git/WIP/Engine:
    - [WIP] — создать/переключиться на ветку carriage/WIP (C-c b c).
    - [Engine] — выбрать текущий движок применения; для 'git — git:in-place|git:wip|git:ephemeral (C-c b e).
    - [Commit] — выполнить коммит (C-c b m — все изменения; C-c b i — только «последняя итерация»).
    - [Reset] — soft reset последнего коммита (C-c b r).

- Переключатели (тумблеры в модлайне):
  - [AutoRpt] — carriage-mode-report-open-policy ('on-error|'always|'never) — политика автооткрытия отчёта (по умолчанию 'on-error).
  - [ShowDiffs] — carriage-mode-show-diffs (t/nil) — требовать предпросмотр диффов перед применением.
  - [ConfirmAll] — carriage-mode-confirm-apply-all (t/nil) — подтверждение перед C-c e A.
  - [Icons] — carriage-mode-use-icons (t/nil) — использовать иконки.
  - [Ctx] — carriage-mode-include-gptel-context (t/nil) — включать gptel-контекст (буферы/файлы; см. ./context-integration-v1.org).
  - [Files] — carriage-mode-include-doc-context (t/nil) — прикладывать файлы из блока #+begin_context документа (лимиты см. ./index.org).
  - Все тумблеры — буферно-локальные; изменение влияет только на текущий буфер carriage-mode; реализация: переменные объявляются через make-variable-buffer-local, а команды-тумблеры используют setq-local.
- Бейдж [Ctx:N] — в модлайне постоянно показывает число элементов контекста, которые будут отправлены при текущих тумблерах; при выключенных источниках отображается [Ctx:-]. Всплывающая подсказка содержит список элементов с их источниками и причинами пропусков (если есть).

- Иконки (при наличии all-the-icons; иначе — текстовые метки в [скобках]):
  - Intent: Ask — material "chat" | Code/Hybrid — material "code".
  - Модель: octicon "cpu" или material "memory".
  - Состояния: sending — spinner, streaming — waves, dry-run — faicon "flask", apply — material "check_circle", error — material "error".
  - Кнопки:
    - Dry — faicon "flask".
    - Apply — material "check_circle".
    - All — octicon "rocket" или material "play_arrow".
    - Abort — octicon "stop".
    - Report — octicon "file-text".
    - Diff — octicon "git-compare".
    - Ediff — octicon "diff".
    - WIP — octicon "git-branch".
    - Commit — octicon "git-commit".
    - Reset — octicon "history".
  - Фоллбэк: если шрифт иконок недоступен — используются короткие текстовые ярлыки: [Dry], [Apply], [All], [Abort], [Report], [Diff], [Ediff], [WIP], [Reset].

- Событийная модель (LLM Transport → UI):  
  - idle → sending (запрос отправлен).
  - sending → streaming (получение частичного ответа).
  - streaming → idle (если блоки не распознаны) | dry-run (если запущено C-c ?/C-c C-c над «последней итерацией»).
  - dry-run → apply → idle | error.
  - Норма: переход sending→streaming инициируется транспортом на первом чанке; UI/команды не переводят состояние в streaming заранее.
  - Любая стадия → error при тайм-ауте/исключении.
  - Примечание: UI обязан отображать одинаковые диапазоны :range для dry-run/apply (см. SRE v1 — консистентность «эффективного диапазона»).
  - Потоковая печать ответа в исходный org-буфер:
    - Каждый STRING-чанк вставляется в исходный carriage-буфер по мере поступления; фокус не переключается, переиспользуется активная позиция «ответа».
    - Reasoning: при событии (reasoning . TEXT) UI открывает/обновляет блок:
      #+begin_reasoning
      …накапливаемый reasoning…
      #+end_reasoning
      Закрыть блок необходимо при (reasoning . t) или завершении стрима (t|ошибка).
    - Основной ответ выводится «как есть» по мере поступления. В Intent=Code допускаются только блоки =begin_patch=; в Intent=Hybrid — текст вперемежку с блоками, парсер извлекает и обрабатывает только блоки.
    - Вставка — строго в исходный org-буфер Carriage; спец-буферы (*carriage-traffic*, *carriage-log*) используются только для диагностики (дублирование необязательно).
    - При отмене/ошибке незакрытый reasoning-блок закрывается, спиннер останавливается, состояние переводится в error.
    - Undo: все вставки потока объединяются в один шаг Undo через change groups; поведение при отмене регулируется переменной carriage-mode-stream-undo-on-abort ('keep|'drop).

* Буфер отчёта (Report)
- Содержимое:
  - Заголовок операции, время, модель.
  - Таблица блоков (строгий формат Org table, не Markdown): №, op, file/path, статус dry-run (ok/fail/skip), details, preview, actions.
    - Первая строка таблицы: | # | op | path | status | matches | details | preview | actions |
    - Вторая строка (разделитель заголовка): |---+----+------+--------+---------+---------+---------+---------|
    - Далее строки данных, по одной на блок.
    - Перед отображением необходимо вызывать org-table-align; запрещены префиксы комментариев («#» в начале строки) и Markdown-таблицы.
  - Требования к данным:
    - Для SRE/AIBO всегда указывать :matches; при наличии — добавлять в details значение :changed-bytes.
    - Статус 'skip использовать для NOOP (after==before); визуально выделять как предупреждение.
  - Кнопки (text-button): Apply/Abort/Show Diff/Ediff.
- Открытие автоматически при dry-run группы, по настройке — при одиночном применении.

* Подсветка и лица (faces)
- carriage-patch-valid-face — окантовка/фон валидного блока.
- carriage-patch-warning-face — для подозрительных блоков.
- carriage-patch-error-face — для ошибочных блоков.
- carriage-report-ok-face, carriage-report-warn-face, carriage-report-err-face — для отчётов.

* Без мыши (доступность)
- Все кликабельные элементы дублируются командами/клавишами.
- В отчёте навигация по кнопкам клавишами [TAB]/[RET].

* Поведение по умолчанию (Customize)
- Открывать отчёт: carriage-mode-report-open-policy ('on-error).
- Открывать лог: carriage-mode-auto-open-log (nil).
- Открывать трафик: carriage-mode-auto-open-traffic (nil).
- Показывать диффы перед применением: carriage-mode-show-diffs (t).
- Требовать подтверждение перед C-c e A: carriage-mode-confirm-apply-all (t).
- Боковое окно для логов/трафика: carriage-mode-aux-window-side (left|right|top|bottom; по умолчанию right).
- Размер бокового окна: carriage-mode-aux-window-size (доля ширины/высоты, по умолчанию 0.33).
- Переиспользовать уже открытое окно: carriage-mode-aux-window-reuse (t); при повторном показе окно не выбирается (фокус остаётся в исходном буфере).
- Иконки: carriage-mode-use-icons (t) — использовать иконки по умолчанию (при наличии all-the-icons).

* Видимость и жизненный цикл UI (норматив)
- Буферная локальность:
  - header-line-format должен устанавливаться и сниматься буферно-локально при включении/выключении carriage-mode.
  - Внесение сегментов в mode-line также должно происходить буферно-локально; глобальные переменные (global-mode-string, mode-line-format) не модифицируются глобально.
- Включение режима:
  - Если carriage-mode-show-header-line=t → установить header-line-format на (:eval (carriage-ui--header-line)).
  - Если carriage-mode-show-mode-line-ui=t → добавить буферно-локальный сегмент (:eval (carriage-ui--modeline)).
- Выключение режима:
  - Восстановить предыдущее значение header-line-format (по умолчанию nil).
  - Удалить буферно-локальные вставки модлайна, оставив только lighter минор-режима.
- Стабильность исходного буфера:
  - Команды dry-run/apply/Report не должны отключать carriage-mode в исходном org-буфере.
  - Исходный org-буфер не переводится в read-only; флаг buffer-read-only остаётся прежним (обычно nil).
  - Read-only допускается только в специальных буферах отчёта/логов.
- Спец-буферы:
  - *carriage-report*, *carriage-log*, *carriage-traffic* — отдельные буферы (special-mode), read-only; в каждом буфере устанавливается header-line с фиксированным заголовком: «Carriage: Report», «Carriage: Log», «Carriage: Traffic». В них действует клавиша q для закрытия окна (quit-window).
  - Открытие/закрытие этих буферов не изменяет состояние исходного буфера (режимы, локальные переменные, header-line/mode-line).
- Фокус:
  - При C-c C-c/C-c ? переключение фокуса в отчёт допускается настройкой, но режим и доступность записи исходного буфера не меняются; возврат по «q»/удалению окна.

* Header-line: формализация
- Состав: project-name › buffer-name › org-outline-path.
  - project-name: по project-root (project.el); фоллбэк — имя корневого каталога git.
  - buffer-name: (buffer-name) целевого org-буфера.
  - org-outline-path: путь заголовков к текущей позиции; фоллбэк — первый заголовок файла.
- Сокращение:
  - Каждый сегмент может сокращаться многоточием в середине при недостатке ширины окна.
  - Политика ширины: общий header-line не должен превышать ширину окна; резерв в конце — ≥ 10 колонок.
- Взаимодействие:
  - Сегменты могут быть кликабельными (опционально): клик по org-outline-path переводит к соответствующему заголовку.
  - Без мыши: доступные действия должны дублироваться командами/клавишами (см. Keymap).
- Деградация:
  - В TTY и при узких окнах допускается показ только project-name › buffer-name (без outline-path).
  - В batch/noninteractive header-line не устанавливается.

* Mode-line: сегменты, состояния и обновление
- Сегменты (в порядке слева направо, минимальная реализация):
  - [Ask|Code|Hybrid] [Suite:sre|udiff], [MODEL], [STATE+spinner], [Dry] [Apply] [All] [Abort] [Report], [Diff] [Ediff], [WIP] [Reset]
  - Тумблеры: [AutoRpt] [ShowDiffs] [ConfirmAll] [Icons]
- Состояния STATE:
  - idle | sending | streaming | dry-run | apply | error.
  - Переходы (событийная модель): idle→sending→streaming→idle/dry-run→apply→idle; любая стадия→error при сбое.
- Спиннер:
  - Отображается при состояниях sending/streaming.
  - Частота обновления: carriage-mode-spinner-interval секунд (по умолчанию 0.15–0.2s).
  - Таймер должен создаваться при входе в sending/streaming и останавливаться при выходе из этих состояний и при выключении режима.
- Кликабельность:
  - Текстовые кнопки ([Dry] и т.д.) — text-button с keymap; без мыши — команды по горячим клавишам.
- Деградация и доступность:
  - При отсутствии all-the-icons использовать текстовые ярлыки в [скобках].
  - Цвет/иконки не должны быть единственным носителем смысла: текстовое состояние — обязательно.

* Немонолитность и отсутствие глобальных побочных эффектов
- UI не должен модифицировать глобальные переменные Emacs, влияющие на все буферы.
- Все изменения ограничены текущим org-буфером с активным carriage-mode.
- Специальные буферы (например, *carriage-report*) не обязаны показывать header-line/mode-line сегменты; допускается собственный UI.

* Поведение в batch/noninteractive
- Не открывать окна с отчётами и ediff; готовить данные (буферы/временные файлы) и выводить сообщения в лог.
- header-line и модлайн-сегменты не инициализировать.

* Переменные Customize (добавление)
- carriage-mode-show-header-line (boolean, default t)
  - Управляет установкой header-line-format в целевом буфере.
- carriage-mode-show-mode-line-ui (boolean, default t)
  - Управляет вставкой сегментов в mode-line буферно-локально.
- carriage-mode-spinner-interval (number, default 0.15)
  - Интервал обновления спиннера состояний.
- carriage-mode-headerline-max-width (integer or nil, default nil)
  - При ненулевом значении — жёсткая максимальная ширина header-line; nil — авто по ширине окна.
- carriage-mode-use-icons (boolean, default t)
  - Использовать иконки, если доступен all-the-icons; иначе — текстовые ярлыки (см. выше).

* Тесты (минимальная матрица для UI)
- Включение/выключение:
  - Включить carriage-mode → header-line-format и модлайн-сегменты установлены буферно-локально.
  - Выключить → восстановлены предыдущие значения, спиннер-таймер отменён.
- Состояния и спиннер:
  - При имитации sending/streaming спиннер изменяется не реже, чем раз в 2*interval; при возврате в idle исчезает.
- Деградация:
  - В TTY/узком окне header-line корректно сокращается и остаётся читабельным.
- Неглобальность:
  - В другом буфере без carriage-mode header-line/mode-line остаются неизменными.

* UI v1

** Addendum v1.1 — Carriage Menu (C-c e) multi-column
- C-c e открывает меню действий (Carriage Menu).
- transient (если доступен):
  - Макет: много-колоночный (2–3 колонки), группы по секциям (:navigate, :act, :session, :tools, :logs).
  - Заголовки групп — через i18n-ключи (см. i18n-v1.org), например: :navigate-title, :act-title, :tools-title.
  - Пункты меню строятся динамически из keyspec; действие :menu исключено из списка.
  - Клавиши:
    - Для многоклавишных сочетаний используется последний токен ("t c" → "c", "t f" → "f").
    - Уникализация при коллизиях: base → UPPER(base) → первая буква :id → цифры "1"…"9".
- Fallback (без transient):
  - completing-read с префиксом секции в метке: "[Section] Label" (Section — i18n).
- which-key:
  - Подсказки: "C-c e" — Carriage Menu; "C-c e t" — Carriage Toggles (строки — через i18n).
- Mode-line и модель:
  - В модлайне показывается только basename модели.
  - Tooltip/help-echo на [MODEL] показывает полный id backend[:provider]:model (строка — через i18n-шаблон).
  - Tooltip/help-echo на [Engine] показывает активный движок; если 'git — включает веточную политику ('in-place|'wip|'ephemeral) по i18n-шаблону (например, "Движок: %s (ветки: %s)").
  - Клик по [MODEL] открывает выбор модели (C-c e m).
- TTY:
  - Текстовый fallback, заголовки секций присутствуют.

** Addendum v1.3 — UI улучшения (цвета, иконки, flash, звук, folding)
- Цвета состояний (faces в модлайне):
  - Новые лица:
    - carriage-ui-state-idle-face — синий (idle).
    - carriage-ui-state-sending-face — зелёный (sending/streaming).
    - carriage-ui-state-error-face — красный (error).
  - Норматив: сегмент состояния (включая спиннер при sending/streaming) окрашивается через propertize с соответствующим face. Остальные состояния (dry-run/apply) — без обязательной перекраски.
  - Доступность: текстовое состояние [idle|sending|…] обязательно, цвет не единственный носитель смысла.

- Иконки для контролов модлайна:
  - Commit: иконка octicon "git-commit" (фоллбэк — текст [Commit]).
  - Intent=Hybrid: отдельная иконка material "merge_type" (или octicon "git-merge"); Intent=Code — material "code"; Intent=Ask — material "chat".
  - Тумблер gptel-context [Ctx]: иконкв  material "toc"; 
  - Suite/Engine как лейблы:
      - Формат отображения: ICON [value] при carriage-mode-use-icons=t и включённых переключателях; в текстовом фоллбэке — "Suite: [udiff]" и "Engine: [git:in-place]".
    - Новые переключатели:
      - carriage-mode-use-suite-icon (boolean, default t) — заменять слово "Suite" на иконку.
      - carriage-mode-use-engine-icon (boolean, default t) — заменять слово "Engine" на иконку.

- Модель (выбор в минибуфере):
  - Правило предзаполнения: если активная модель — "gptel-default", initial-input в промпте выбора модели пустой; иначе — предзаполняется полным id backend[:provider]:model (как прежде).

- Эффекты завершения запроса:
  - Flash патчей: по успешному завершению запроса все блоки «последней итерации» визуально подсвечиваются на короткое время (~1 сек).
    - Настройки:
      - carriage-mode-flash-patches (boolean, default t) — включить/выключить эффект.
      - carriage-mode-flash-duration (number, default 1.0) — длительность, сек.
    - Реализация: предпочтительно pulse.el (pulse-momentary-highlight-region); фоллбэк — временные overlays с последующим удалением.
  - Звук (опционально): по завершении запроса (успех; по желанию также для ошибки) можно подать звуковой сигнал.
    - Настройки:
      - carriage-mode-audio-notify (boolean, default nil) — включить звуковое уведомление.
      - carriage-mode-audio-sound (symbol|string) — 'beep или путь к файлу для play-sound-file.
    - Поведение по умолчанию — тихо (notify=nil).

- Reasoning folding:
  - Сразу после закрытия reasoning-блока (вставлен "#+end_reasoning") содержимое блока автоматически сворачивается.
  - Норматив: при наличии org-fold — использовать org-fold для скрытия содержимого блока; фоллбэк — overlay 'invisible на теле блока. Повторное раскрытие — стандартным org-cycle.

 ** I18N integration (UI)
 - All visible labels (buttons, help-echo, headers, which-key hints, transient titles) must be resolved via the i18n layer.
 - Locale switching must update UI labels without global side-effects; buffer-local mode-line refresh required (force-mode-line-update).

 ** Addendum v1.4 — Видимость кнопок модлайна
 - Abort:
   - Кнопка [Abort] отображается только при наличии активного обработчика отмены
     (в буфере установлен carriage--abort-handler).
 - Apply/Dry-run:
   - Кнопки [Apply]/[Dry] отображаются, только если:
     - точка находится внутри блока #+begin_patch … #+end_patch, или
     - активный регион содержит хотя бы один такой блок.
 - Apply last iteration:
   - Кнопка [All] (применить «последнюю итерацию») отображается, только если
     в буфере присутствуют блоки «последней итерации» (по совпадению text-property
     'carriage-iteration-id с текущим carriage--last-iteration-id).
 - Примечание по производительности:
   - Проверки видимости кэшируются по buffer-chars-modified-tick и идентификатору
     последней итерации, чтобы не сканировать буфер на каждом кадре модлайна.

 ** Addendum v1.2 — Префикс C-c e, carriage-global-mode и проектный буфер
 - Норматив ключей и transient:
   - По умолчанию transient включён (carriage-mode-use-transient=t): в carriage-mode сочетание C-c e сразу открывает меню (без дополнительной «e»).
   - Если carriage-mode-use-transient=nil — C-c e становится префиксом; под ним действуют keyspec-суффиксы (например, "t c").
   - Вне carriage-mode C-c e не занят, за исключением включённого carriage-global-mode.
 - carriage-global-mode (глобальный минор-режим):
   - При включении регистрирует глобальный префикс C-c e и строит меню/префикс только из действий :contexts (global).
   - В буферах carriage-mode одновременно действуют и global-, и carriage-клавиши; при коллизии приоритет у локального контекста (carriage > report/log/traffic > global).
   - which-key: "C-c e" — Carriage Menu (global), "C-c e t" — Carriage Toggles (если тумблеры объявлены в global).
 - Источник правды по клавишам:
   - Любые биндинги настраиваются через keyspec; статический (defvar carriage-mode-map ...) в carriage-ui.el запрещён.
   - В дочерних спец-буферах (report/log/traffic) клавиши задаются контекстами keyspec; локальные define-key в этих файлах недопустимы.
 - Проектный буфер без файла (carriage-open-buffer):
   - Действие из :contexts (global), рекомендуемая клавиша "e" под префиксом C-c e в global-меню.
   - Открывает (или переключает на существующий) уникальный для текущего проекта буфер с включённым carriage-mode и default-directory в корне проекта.
   - Буфер помечается как «эфемерный проектный»; при попытке выхода из Emacs система должна предложить сохранить такие буферы в файл (через kill-emacs-query-functions).
   - Поведение в TTY/без transient: fallback-меню через completing-read; пункт :menu исключается из списка.



