#+title: UI v1 — Клавиши, header-line, mode-line, отчёты
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t

* Назначение
- Норматив интерфейса пользователя: навигация, применение, визуализация.

* Keymap (org-mode только)
Примечание: начиная с UI v1.1, все команды Carriage должны иметь префикс C-c e и описываются централизованно через keyspec (см. ./keyspec-v1.org). Ниже приведённые сочетания — легаси и могут поддерживаться для совместимости.

- C-c M-RET — отправить весь документ (поведение зависит от Intent: Ask|Patch).
- C-c RET — отправить текущее поддерево.
- C-c C-c — dry-run → подтверждение → применить блок =patch= под точкой.
- C-c ! — применить все блоки из «последней итерации».
- C-c ? — только dry-run текущего блока (или всей «последней итерации» при префикс-аргументе).
- M-n / M-p — навигация по блокам =patch=.
- C-c b c — создать/перейти на ветку carriage/WIP.
- C-c b l — показать лог применений (буфер лога).
- C-c b t — показать трафик LLM (буфер трафика).
- C-c b L — открыть лог и трафик одновременно в правых боковых окнах.
- C-c b r — откат последнего коммита (soft reset).
- C-c b m — выполнить коммит всех изменений (проиндексирует по политике при необходимости).
- C-c b i — выполнить коммит файлов «последней итерации».
- C-c b e — выбрать движок применения (Apply Engine).

* Header-line
- Состав: project-name → buffer-name → org-outline-path.
- Сокращение длинных сегментов многоточием в середине.
- Клики (опционально): переход к заголовку, раскрытие/сворачивание узла.

* Mode-line
- Сегменты и кнопки (кликабельно; без мыши — дублируются командами/клавишами):
  - Intent: [Ask|Patch] — переключение намерения ответа (toggle).
  - Suite: [auto|sre|patch|fileops] — выбор набора допустимых операций/шаблонов.
  - Модель: [MODEL] — выбор модели (в модлайне показывается только имя модели).
  - Состояние: [idle|sending|streaming|dry-run|apply|error] + индикатор-спиннер для sending/streaming.
  - Управление циклом:
    - [Dry] — запустить dry-run под точкой (C-c ?).
    - [Apply] — dry-run → подтверждение → применить под точкой (C-c C-c).
    - [All] — применить все блоки «последней итерации» (C-c !).
    - [Abort] — отменить текущий запрос/применение (отмена запроса к LLM/пайплайна).
    - [Report] — открыть буфер отчёта (C-c b l).
  - Просмотр:
    - [Diff] — показать мини-дифф текущего блока (если доступен).
    - [Ediff] — открыть ediff для текущего файла/патча.
  - Git/WIP/Engine:
    - [WIP] — создать/переключиться на ветку carriage/WIP (C-c b c).
    - [Engine] — выбрать текущий движок применения (C-c b e).
    - [Commit] — выполнить коммит (C-c b m — все изменения; C-c b i — только «последняя итерация»).
    - [Reset] — soft reset последнего коммита (C-c b r).

- Переключатели (тумблеры в модлайне):
  - [AutoRpt] — carriage-mode-auto-open-report (t/nil) — автооткрытие отчёта после dry-run.
  - [ShowDiffs] — carriage-mode-show-diffs (t/nil) — требовать предпросмотр диффов перед применением.
  - [ConfirmAll] — carriage-mode-confirm-apply-all (t/nil) — подтверждение перед C-c !.
  - [Icons] — carriage-mode-use-icons (t/nil) — использовать иконки.

- Иконки (при наличии all-the-icons; иначе — текстовые метки в [скобках]):
  - Intent: Ask — material "chat" | Patch — material "code".  - Модель: octicon "cpu" или material "memory".
  - Состояния: sending — spinner, streaming — waves, dry-run — faicon "flask", apply — material "check_circle", error — material "error".
  - Кнопки:
    - Dry — faicon "flask".
    - Apply — material "check_circle".
    - All — octicon "rocket" или material "play_arrow".
    - Abort — octicon "stop".
    - Report — octicon "file-text".
    - Diff — octicon "git-compare".
    - Ediff — octicon "diff".
    - WIP — octicon "git-branch".
    - Reset — octicon "history".
  - Фоллбэк: если шрифт иконок недоступен — используются короткие текстовые ярлыки: [Dry], [Apply], [All], [Abort], [Report], [Diff], [Ediff], [WIP], [Reset].

- Событийная модель (LLM Transport → UI):  
  - idle → sending (запрос отправлен).
  - sending → streaming (получение частичного ответа).
  - streaming → idle (если блоки не распознаны) | dry-run (если запущено C-c ?/C-c C-c над «последней итерацией»).
  - dry-run → apply → idle | error.
  - Норма: переход sending→streaming инициируется транспортом на первом чанке; UI/команды не переводят состояние в streaming заранее.
  - Любая стадия → error при тайм-ауте/исключении.
  - Примечание: UI обязан отображать одинаковые диапазоны :range для dry-run/apply (см. SRE v1 — консистентность «эффективного диапазона»).
  - Потоковая печать ответа в исходный org-буфер:
    - Каждый STRING-чанк вставляется в исходный carriage-буфер по мере поступления; фокус не переключается, переиспользуется активная позиция «ответа».
    - Reasoning: при событии (reasoning . TEXT) UI открывает/обновляет блок:
      #+begin_reasoning
      …накапливаемый reasoning…
      #+end_reasoning
      Закрыть блок необходимо при (reasoning . t) или завершении стрима (t|ошибка).
    - Основной ответ выводится «как есть» по мере поступления. В Intent=Patch допускаются сразу блоки =begin_patch= — они печатаются без фильтрации; последующая обработка выполнится парсером по правилам v1.
    - Вставка — строго в исходный org-буфер Carriage; спец-буферы (*carriage-traffic*, *carriage-log*) используются только для диагностики (дублирование необязательно).
    - При отмене/ошибке незакрытый reasoning-блок закрывается, спиннер останавливается, состояние переводится в error.

* Буфер отчёта (Report)
- Содержимое:
  - Заголовок операции, время, модель.
  - Таблица блоков (строгий формат Org table, не Markdown): №, op, file/path, статус dry-run (ok/fail), details, preview, actions.
    - Первая строка таблицы: | # | op | path | status | matches | details | preview | actions |
    - Вторая строка (разделитель заголовка): |---+----+------+--------+---------+---------+---------+---------|
    - Далее строки данных, по одной на блок.
    - Перед отображением необходимо вызывать org-table-align; запрещены префиксы комментариев («#» в начале строки) и Markdown-таблицы.
  - Кнопки (text-button): Apply/Abort/Show Diff/Ediff.
- Открытие автоматически при dry-run группы, по настройке — при одиночном применении.

* Подсветка и лица (faces)
- carriage-patch-valid-face — окантовка/фон валидного блока.
- carriage-patch-warning-face — для подозрительных блоков.
- carriage-patch-error-face — для ошибочных блоков.
- carriage-report-ok-face, carriage-report-warn-face, carriage-report-err-face — для отчётов.

* Без мыши (доступность)
- Все кликабельные элементы дублируются командами/клавишами.
- В отчёте навигация по кнопкам клавишами [TAB]/[RET].

* Поведение по умолчанию (Customize)
- Открывать отчёт: carriage-mode-auto-open-report (t).
- Открывать лог: carriage-mode-auto-open-log (nil).
- Открывать трафик: carriage-mode-auto-open-traffic (nil).
- Показывать диффы перед применением: carriage-mode-show-diffs (t).
- Требовать подтверждение перед C-c !: carriage-mode-confirm-apply-all (t).
- Боковое окно для логов/трафика: carriage-mode-aux-window-side (left|right|top|bottom; по умолчанию right).
- Размер бокового окна: carriage-mode-aux-window-size (доля ширины/высоты, по умолчанию 0.33).
- Переиспользовать уже открытое окно: carriage-mode-aux-window-reuse (t); при повторном показе окно не выбирается (фокус остаётся в исходном буфере).
- Иконки: carriage-mode-use-icons (t) — использовать иконки по умолчанию (при наличии all-the-icons).

* Видимость и жизненный цикл UI (норматив)
- Буферная локальность:
  - header-line-format должен устанавливаться и сниматься буферно-локально при включении/выключении carriage-mode.
  - Внесение сегментов в mode-line также должно происходить буферно-локально; глобальные переменные (global-mode-string, mode-line-format) не модифицируются глобально.
- Включение режима:
  - Если carriage-mode-show-header-line=t → установить header-line-format на (:eval (carriage-ui--header-line)).
  - Если carriage-mode-show-mode-line-ui=t → добавить буферно-локальный сегмент (:eval (carriage-ui--modeline)).
- Выключение режима:
  - Восстановить предыдущее значение header-line-format (по умолчанию nil).
  - Удалить буферно-локальные вставки модлайна, оставив только lighter минор-режима.
- Стабильность исходного буфера:
  - Команды dry-run/apply/Report не должны отключать carriage-mode в исходном org-буфере.
  - Исходный org-буфер не переводится в read-only; флаг buffer-read-only остаётся прежним (обычно nil).
  - Read-only допускается только в специальных буферах отчёта/логов.
- Спец-буферы:
  - *carriage-report*, *carriage-log*, *carriage-traffic* — отдельные буферы (special-mode), по умолчанию read-only; в них действует клавиша q для закрытия окна (quit-window).
  - Открытие/закрытие этих буферов не изменяет состояние исходного буфера (режимы, локальные переменные, header-line/mode-line).
- Фокус:
  - При C-c C-c/C-c ? переключение фокуса в отчёт допускается настройкой, но режим и доступность записи исходного буфера не меняются; возврат по «q»/удалению окна.

* Header-line: формализация
- Состав: project-name › buffer-name › org-outline-path.
  - project-name: по project-root (project.el); фоллбэк — имя корневого каталога git.
  - buffer-name: (buffer-name) целевого org-буфера.
  - org-outline-path: путь заголовков к текущей позиции; фоллбэк — первый заголовок файла.
- Сокращение:
  - Каждый сегмент может сокращаться многоточием в середине при недостатке ширины окна.
  - Политика ширины: общий header-line не должен превышать ширину окна; резерв в конце — ≥ 10 колонок.
- Взаимодействие:
  - Сегменты могут быть кликабельными (опционально): клик по org-outline-path переводит к соответствующему заголовку.
  - Без мыши: доступные действия должны дублироваться командами/клавишами (см. Keymap).
- Деградация:
  - В TTY и при узких окнах допускается показ только project-name › buffer-name (без outline-path).
  - В batch/noninteractive header-line не устанавливается.

* Mode-line: сегменты, состояния и обновление
- Сегменты (в порядке слева направо, минимальная реализация):
  - [Ask|Patch] [Suite:auto|sre|patch|fileops], [MODEL], [STATE+spinner], [Dry] [Apply] [All] [Abort] [Report], [Diff] [Ediff], [WIP] [Reset]
  - Тумблеры: [AutoRpt] [ShowDiffs] [ConfirmAll] [Icons]
- Состояния STATE:
  - idle | sending | streaming | dry-run | apply | error.
  - Переходы (событийная модель): idle→sending→streaming→idle/dry-run→apply→idle; любая стадия→error при сбое.
- Спиннер:
  - Отображается при состояниях sending/streaming.
  - Частота обновления: carriage-mode-spinner-interval секунд (по умолчанию 0.15–0.2s).
  - Таймер должен создаваться при входе в sending/streaming и останавливаться при выходе из этих состояний и при выключении режима.
- Кликабельность:
  - Текстовые кнопки ([Dry] и т.д.) — text-button с keymap; без мыши — команды по горячим клавишам.
- Деградация и доступность:
  - При отсутствии all-the-icons использовать текстовые ярлыки в [скобках].
  - Цвет/иконки не должны быть единственным носителем смысла: текстовое состояние — обязательно.

* Немонолитность и отсутствие глобальных побочных эффектов
- UI не должен модифицировать глобальные переменные Emacs, влияющие на все буферы.
- Все изменения ограничены текущим org-буфером с активным carriage-mode.
- Специальные буферы (например, *carriage-report*) не обязаны показывать header-line/mode-line сегменты; допускается собственный UI.

* Поведение в batch/noninteractive
- Не открывать окна с отчётами и ediff; готовить данные (буферы/временные файлы) и выводить сообщения в лог.
- header-line и модлайн-сегменты не инициализировать.

* Переменные Customize (добавление)
- carriage-mode-show-header-line (boolean, default t)
  - Управляет установкой header-line-format в целевом буфере.
- carriage-mode-show-mode-line-ui (boolean, default t)
  - Управляет вставкой сегментов в mode-line буферно-локально.
- carriage-mode-spinner-interval (number, default 0.15)
  - Интервал обновления спиннера состояний.
- carriage-mode-headerline-max-width (integer or nil, default nil)
  - При ненулевом значении — жёсткая максимальная ширина header-line; nil — авто по ширине окна.
- carriage-mode-use-icons (boolean, default t)
  - Использовать иконки, если доступен all-the-icons; иначе — текстовые ярлыки (см. выше).

* Тесты (минимальная матрица для UI)
- Включение/выключение:
  - Включить carriage-mode → header-line-format и модлайн-сегменты установлены буферно-локально.
  - Выключить → восстановлены предыдущие значения, спиннер-таймер отменён.
- Состояния и спиннер:
  - При имитации sending/streaming спиннер изменяется не реже, чем раз в 2*interval; при возврате в idle исчезает.
- Деградация:
  - В TTY/узком окне header-line корректно сокращается и остаётся читабельным.
- Неглобальность:
  - В другом буфере без carriage-mode header-line/mode-line остаются неизменными.

* UI v1.1 — Изменения (модель, контекст, биндинги)
- Mode-line — модель:
  - В модлайне отображается только «basename» модели (последний сегмент после «:»). Пример: "gptel:ai-tunnel:gpt-5" → "gpt-5".
  - Клик по сегменту модели (или команда) открывает выбор с полными идентификаторами; минибуфер предзаполнен текущим полным id.
- Выбор модели:
  - Команда carriage-select-model предзаполняет ввод текущим полным id; кандидаты включают формы "backend:provider:model" и "backend:model".
  - Норма биндинга: C-c e m.
- Тумблеры контекста в модлайне:
  - [Ctx] — включать/исключать gptel-context (буферы/файлы из gptel), по умолчанию on.
  - [Files] — включать/исключать файлы из блока #+begin_context в документе, по умолчанию on.
  - Иконки: "link"/"description" (material) при наличии all-the-icons; фоллбэк — текстовые ярлыки [Ctx]/[Files].
  - Нормативные команды: carriage-toggle-include-gptel-context (C-c e t c), carriage-toggle-include-doc-context (C-c e t f).
- Префикс клавиш:
  - Все клавиши режима должны начинаться с C-c e. Исторические биндинги могут сохраняться как временная совместимость.
- Деградация:
  - В TTY — текстовые ярлыки [Ctx]/[Files]; поведение идентично.

