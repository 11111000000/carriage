#+title: File Ops v1 — create/delete/rename
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t
#+property: header-args :results silent

* Назначение и охват
- Норматив форматов блоков =patch= для операций над файлами:
  - :op "create" — создать файл с содержимым.
  - :op "delete" — удалить файл.
  - :op "rename" — переименовать/переместить файл.
  - :op "replace" — полностью переписать содержимое существующего файла.
- Цель v1: минимальная и надёжная спецификация, совместимая с общим пайплайном (dry-run → применить → git).

* Общие нормы
- Имя спец-блока: см. ./parser-registry-v1.org (единое имя блока =begin_patch/end_patch=).
- Политика путей: см. ./security-v1.org (относительные пути, запрет абсолютов и «..»).
- Один блок = одна операция — см. ./index.org (раздел «Инварианты v1»).
- Dry-run и подтверждения: см. ./apply-pipeline-v1.org и ./ui-v1.org.

* Блок :op "create"
** Заголовок
- #+begin_patch (:version "1" :op "create" :file "relative/path" [:mkdir t|nil])
- #+end_patch

Ключи:
- :version — "1".
- :op — "create".
- :file — относительный путь создаваемого файла.
- :mkdir — t для создания недостающих каталогов (по умолчанию t).
- :ensure-final-newline — добавлять завершающую новую строку при сохранении (по умолчанию t).

** Тело
- Содержимое файла — всё, что находится между #+begin_patch и #+end_patch; никаких специальных маркеров не требуется.

** Валидация (create)
- Путь внутри репозитория; каталоги допускается создать при :mkdir t.
- Файл не должен существовать; иначе OPS_E_EXISTS (если не предусмотрена политика overwrite в будущих версиях).

** Dry-run (create)
- Проверить доступность пути и отсутствие файла.
- Предпросмотр: показать размер создаваемого содержимого (байт).

** Применение (create)
- Создать каталоги при необходимости (:mkdir t).
- Записать файл; если содержимое не заканчивается переводом строки и :ensure-final-newline=t — добавить завершающую новую строку.
- Индексация по политике стадирования (carriage-apply-stage-policy); по умолчанию — без индексации.
- Коммит не выполняется в apply; он запускается отдельной командой пользователя.

** Пример (create)
#+begin_patch (:version "1" :op "create" :file "docs/intro.md")
* Intro
Welcome to Carriage.
#+end_patch

* Блок :op "delete"
** Заголовок
- #+begin_patch (:version "1" :op "delete" :file "relative/path")
- #+end_patch

** Тело
- Пусто.

** Валидация (delete)
- Путь внутри репозитория; файл должен существовать (иначе OPS_E_NOT_FOUND).
- Дополнительные проверки (по политике безопасности): запрет удаления вне списка разрешённых директорий (опционально, не в v1).

** Dry-run (delete)
- Сообщить о намерении удалить файл; показать размер и последнее изменение (по желанию инструмента).

** Применение (delete)
- Выполнить через активный движок (см. ./apply-engines-v1.org):
  - 'git: git rm (или git rm --cached --force по состоянию); стадирование по policy.
  - 'emacs: удаление файла средствами файловой системы; индексации нет.
- Коммит — отдельная команда пользователя (не часть apply).

** Пример (delete)
#+begin_patch (:version "1" :op "delete" :file "tmp/old.log")
#+end_patch

* Блок :op "rename"
** Заголовок
- #+begin_patch (:version "1" :op "rename" :from "old/relpath" :to "new/relpath")
- #+end_patch

Ключи:
- :from — исходный относительный путь.
- :to — целевой относительный путь.

** Тело
- Пусто.

** Валидация (rename)
- Оба пути внутри репозитория; :from существует; :to не должен существовать (иначе OPS_E_EXISTS).
- Переименование между разными файловыми системами не поддерживается (локальная операция Git).

** Dry-run (rename)
- Отобразить старый и новый путь; отметить, что последующие блоки должны использовать :to как новый путь.

** Применение (rename)
- Выполнить через активный движок:
  - 'git: git mv :from :to; стадирование по policy.
  - 'emacs: rename-file :from :to; индексации нет.
- Коммит — отдельная команда пользователя (не часть apply).

** Пример (rename)
#+begin_patch (:version "1" :op "rename" :from "lib/legacy.c" :to "src/core/legacy.c")
#+end_patch

* Блок :op "replace"
** Заголовок
- #+begin_patch (:version "1" :op "replace" :file "relative/path")
- #+end_patch

Ключи:
- :version — "1".
- :op — "replace".
- :file — относительный путь существующего файла.
- :ensure-final-newline — добавлять завершающую новую строку при сохранении (по умолчанию t).

** Тело
- Новое содержимое файла — всё, что находится между #+begin_patch и #+end_patch; никаких специальных маркеров не требуется.

** Валидация (replace)
- Путь внутри репозитория; файл должен существовать (иначе OPS_E_NOT_FOUND).
- Для создания нового файла используйте :op "create".

** Dry-run (replace)
- Проверить доступность пути и существование файла.
- Предпросмотр: показать размер заменяемого содержимого (байт) и ожидаемый размер нового.
- NOOP: если содержимое совпадает байт-в-байт — статус 'skip.

** Применение (replace)
- Перезаписать файл новым содержимым атомарно (temp → rename), сохранив права.
- Если содержимое не заканчивается переводом строки и :ensure-final-newline=t — добавить завершающую новую строку.
- Индексация по политике стадирования (carriage-apply-stage-policy); по умолчанию — без индексации.

** Пример (replace)
#+begin_patch (:version "1" :op "replace" :file "docs/intro.md")
* Intro
Welcome to Carriage v2.
#+end_patch

* Формальная грамматика (EBNF)
#+begin_src text
patch-block   := patch-header newline patch-body patch-footer
patch-header  := "#+begin_patch" ws plist newline
patch-footer  := "#+end_patch" newline?
plist         := "(" ws kv-pair (ws kv-pair)* ws ")"
kv-pair       := ":"symbol ws value
value         := string | number | symbol | list

; create
create-required := :version "1" :op "create" :file "relative/path"
create-optional := (:mkdir t|nil)
create-body     := segment

; delete
delete-required := :version "1" :op "delete" :file "relative/path"
delete-body     := ε

; rename
rename-required := :version "1" :op "rename" :from "old" :to "new"
rename-body     := ε

; replace
replace-required := :version "1" :op "replace" :file "relative/path"
replace-body     := segment

segment         := segment-open payload segment-close
