#+title: Extensibility Points v1 — Точки расширения
#+author: Carriage Team
#+language: ru
#+options: toc:2 num:t

* Назначение
- Описать стабильные точки расширения: новые :op, транспорты LLM/агенты, UI-сегменты и действия.

* Новые операции (:op)
- Реестр: см. ./parser-registry-v1.org (parse/dry-run/apply).
- Контракты: см. ./parser-impl-v1.org (единые сигнатуры).
- Требования:
  - Отдельная спецификация формата в spec/, EBNF, ошибки в errors-v1.
  - Реализация в lisp/ops/<op>.el (или carriage-<op>.el); тесты ERT.
  - Без зависимостей на UI (строго).

* Сьюиты (Suites)
- Suite — композиция разрешённых :op и собранного системного промпта.
- Роль Suite — определить белый список :ops (:ops-allowed) и стратегию сборки единого системного промпта из фрагментов форматов.
- Норматив для op-модулей (lisp/ops/<op>.el):
  - Зарегистрировать parse/dry-run/apply в реестре (см. ./parser-registry-v1.org).
  - Опубликовать промпт-фрагмент для композиции Suite: строка или функция (CTX → STRING), рекомендуемое имя символа: carriage-op-<op>-prompt-fragment.
  - Документировать формат отдельным файлом в spec/*-v1.org (EBNF, ошибки).
- Сборка Suite (алгоритм):
  0) Получить базовый список (:ops-allowed …) для выбранного suite и применить overlays из carriage-prompt-suite-overlays (если задан).
  1) Сформировать fragments:
     - Для каждого разрешённого :op взять фрагмент из carriage-op-fragment-overrides[op], иначе — из op-модуля (STRING|FN (CTX→STRING)); если FN — вычислить по CTX.
  2) Получить intent-фрагмент: carriage-intent-fragment-overrides[intent] || (carriage-intent-get intent); если FN — вычислить по CTX.
  3) guardrails (строгие правила): только begin_patch/end_patch; относительные пути; DELIM только для create; для Suite='sre запрет unified diff; для Suite='udiff запрет begin_from/begin_to; Intent=Code — запрет текста вне блоков; Intent=Hybrid — текст допускается, применяется только содержимое блоков.
  4) Сконкатенировать: system ← guardrails + intent-fragment + join(fragments,"\n\n"); prompt ← payload (+ опционально контекст).
  5) Выполнить asserts: в system нет маркеров неразрешённых форматов (см. prompt-profiles-v1.org/Builder v1 — список якорей).
  6) Передать system/prompt транспорту.

Примечание:
- Промпты не используют i18n; поставляются на одном языке (en). Заменяемость обеспечивается overrides (см. переменные конфигурации).
- op-модули публикуют только свой формат/шаблон и не упоминают другие форматы.
- Базовые сьюиты v1:
  - 'sre → (sre, create, delete, rename).
  - 'udiff → (patch, create, delete, rename).
  - Примечание: file-ops разрешены в обоих сьюитах; отдельного suite для file-ops нет.
- UI:
  - Предоставляет выбор suite и toggle intent (Ask|Code|Hybrid) в модлайне.
  - При Intent=Code ответы ДОЛЖНЫ состоять только из блоков begin_patch/end_patch; в Intent=Hybrid текст вне блоков допускается, применяется только содержимое блоков.

* Транспорты LLM/агенты
- Абстракция: ./llm-transport-v1.org (carriage-llm-request/abort, события, capabilities).
- Адаптеры: lisp/transports/<backend>.el; не трогают UI/глобальные переменные.
- Совместимость: gptel через адаптер; JSON-RPC/Agent — расширением.

* UI расширения
- Header-line/mode-line сегменты — буферно-локальные (:eval builders).
- Кнопки — text-button с keymap; альтернативы без мыши (горячие клавиши).
- Новые компоненты UI — в lisp/ui/*.el; без глобальных эффектов для mode-line-format/global-mode-string.

* Диагностика
- Ошибки и предупреждения регистрируются в errors-v1 и в таблице ошибок runtime.
- Предпочитать специфичные коды (например, PATCH_E_RENAME_COPY, PATCH_E_BINARY).

* Тесты (минимум)
- Юнит: parse/dry-run/apply/ошибки.
- Интеграция: git-репо, отчёты, UI-реакции на события транспорта (моки).

* Политика слоёв
- Расширения уважают границы: UI сверху, parser/apply снизу, транспорты сбоку.
