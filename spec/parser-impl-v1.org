#+title: Parser/Applier Impl v1 — Контракты и скелеты
#+author: Peter Kosov <11111000000@email.com>
#+language: ru
#+options: toc:2 num:t
#+property: header-args :results silent

* Назначение
- Нормативные интерфейсы функций parse/dry-run/apply для всех :op v1.
- Скелеты Emacs Lisp для унификации реализации.
- Диспетчеризация реализована через реестр форматов (:op,:version) (см. ./parser-registry-v1.org).

* Общие интерфейсы
- parse(op, header-plist, body-text, repo-root) → plan-item | error
  - На вход: plist заголовка, тело блока (между begin/end), корень репо.
  - На выход: элемент плана (см. ./data-structures-v1.org) или ошибка.
- dry-run(PLAN-ITEM, REPO) → REPORT-ITEM[, DIFF]
- apply(PLAN-ITEM, REPO) → RESULT
- Все функции должны сигнализировать условия (define-error) с кодами ./errors-v1.org.
- Алиасы :op запрещены (MODE_E_DISPATCH). Разрешение возможно только в режиме совместимости (defcustom carriage-mode-allow-op-aliases=t), что выводит реализацию за рамки строгого v1; по умолчанию nil.

* SRE v1 — begin_from/begin_to (без DELIM)
- Парсинг SRE выполняется по спецблокам "#+begin_from … #+end_from" и "#+begin_to … #+end_to".
- Директива "#+pair (<plist>)" задаёт опции для следующей пары и затем «сбрасывается».
- Экранирование: если строка содержимого ровно равна "#+end_from" или "#+end_to", она должна быть записана с одним ведущим пробелом; парсер снимает один пробел при извлечении.
- Ошибки:
  - SRE_E_UNPAIRED — from без последующего to.
  - SRE_E_UNCLOSED_BLOCK — отсутствует закрывающий end-блок.
  - SRE_E_SEGMENTS_COUNT — нет ни одной пары.
  - SRE_E_OCCUR_EXPECT — :occur all без :expect.
  - SRE_E_LIMITS — лимиты пар/размеров (см. FREEZE).
- Внутреннее представление: (:pairs ((:from STR :to STR :opts PLIST) ...)).

* Скелеты (Elisp)
#+end_#+begin_src emacs-lisp
(cl-defgeneric carriage-parse (op header-plist body-text repo-root))
(cl-defgeneric carriage-dry-run (plan-item repo-root))
(cl-defgeneric carriage-apply (plan-item repo-root))

(defun carriage-generate-delim ()
  "Вернуть случайный токен длиной ровно 6 нижних hex-символов ([0-9a-f])."
  (let* ((b1 (random 256))
         (b2 (random 256))
         (b3 (random 256)))
    (format "%02x%02x%02x" b1 b2 b3)))

(defun carriage-parse-sre (header body repo-root)
  "Парсинг SRE v1 (begin_from/begin_to) по спецификации v1."
  ;; 1) Проверить :version, :op='sre, :file; валидировать и нормализовать путь (внутри корня).
  ;; 2) Сканировать BODY построчно:
  ;;    - встречая \"#+pair (PLIST)\" — сохранить pending-opts для следующей пары;
  ;;    - \"#+begin_from\" → читать до \"#+end_from\" (с экранированием одной ведущей пробельной строки для ровного \"#+end_from\");
  ;;    - \"#+begin_to\"   → читать до \"#+end_to\"   (с тем же правилом); сформировать пару с opts = defaults ∪ pending-opts; сбросить pending-opts.
  ;; 3) Ошибки: from без to → SRE_E_UNPAIRED; незакрытый блок → SRE_E_UNCLOSED_BLOCK; нет пар → SRE_E_SEGMENTS_COUNT;
  ;;    :occur all и нет :expect → SRE_E_OCCUR_EXPECT; превышение лимитов → SRE_E_LIMITS.
  ;; 4) Вернуть элемент плана: '(:version \"1\" :op 'sre :file PATH :pairs LIST-OF-PAIRS)
  )

(defun carriage-dry-run-sre (plan-item repo-root)
  "Подсчитать совпадения, собрать мини-диффы и отчёт."
  ;; учитывать :occur, :expect, :match, :range
  )

(defun carriage-apply-sre (plan-item repo-root)
  "Применить пары по порядку; при необходимости — индексация по политике; без коммита."
  )

(defun carriage-parse-diff (header body repo-root)
  "Парсинг unified diff одного файла."
  ;; извлечь ---/+++ пути; проверить одиночность файла; подготовить :diff и :path
  )

(defun carriage-dry-run-diff (plan-item repo-root)
  "Выполнить git apply --check и собрать вывод."
  )

(defun carriage-apply-diff (plan-item repo-root)
  "Делегировать применение активному движку: по умолчанию 'git использует git apply [--index]; без коммита."
  )

(defun carriage-parse-create (header body repo-root)
  "Парсинг create: один сегмент CONTENT."
  )

(defun carriage-parse-delete (header body repo-root) )
(defun carriage-parse-rename (header body repo-root) )

(defun carriage-dry-run-create (plan-item repo-root) )
(defun carriage-dry-run-delete (plan-item repo-root) )
(defun carriage-dry-run-rename (plan-item repo-root) )

(defun carriage-apply-create (plan-item repo-root) )
(defun carriage-apply-delete (plan-item repo-root) )
(defun carriage-apply-rename (plan-item repo-root) )
