#+title: Локальные переключатели
#+author: Carriage Team
#+language: ru
#+options: toc:2 num:t

* Задача
- Переключатели и настройки, влияющие на формирование и отправку запроса, должны быть буферно-локальными для каждого org-буфера с включённым carriage-mode.

* Диалектический анализ
- Тезис: глобальные defcustom-переменные удобны для настройки по умолчанию, но при реальной работе нужно, чтобы отдельные буферы могли иметь разные значения (например, включать/выключать источники контекста независимо).
- Антитезис: простая замена на локальные переменные может нарушить пользовательские глобальные настройки и совместимость, а также усложнить доступ к значениям по умолчанию.
- Синтез: сохранить defcustom как источник глобального «дефолта», но сделать рабочие значения буферно-локальными:
  - пометить соответствующие переменные через make-variable-buffer-local;
  - в командах-тумблерах и при включении carriage-mode использовать setq-local для установки локального значения по дефолту и при переключении;
  - функции, формирующие контекст и промпт, читать локальные значения (с откатом к дефолту при отсутствии локального).

* Решение
- Пометить как буферно-локальные ключевые переменные, влияющие на «send»:
  - Источники контекста: carriage-mode-include-gptel-context, carriage-mode-include-doc-context (уже локальные).
  - Параметры инъекции и лимиты: carriage-mode-context-injection, carriage-mode-context-max-files, carriage-mode-context-max-total-bytes (сделаны локальными).
  - Вспомогательные UI-настройки отправки (открытие логов/трафика при отправке): carriage-mode-auto-open-log (локальная), carriage-mode-auto-open-traffic (сделана локальной).
- Команды-тумблеры использовать setq-local, чтобы изменения не «утекали» в другие буферы.
- UI: учитывать локальные значения в бейдже [Ctx:N] и кэш-ключах модельной строки.
- Тесты: сценарии с двумя буферами подтверждают независимость локальных значений.

* Контекст (файлы)
#+begin_context
spec/ui-v1.org
spec/context-integration-v1.org
spec/project-overview-v1.org
lisp/carriage-mode.el
lisp/carriage-ui.el
lisp/carriage-context.el
test/carriage-mode-toggle-tests.el
#+end_context
